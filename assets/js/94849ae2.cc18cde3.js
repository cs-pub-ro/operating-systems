"use strict";(self.webpackChunkso=self.webpackChunkso||[]).push([[1055],{5680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>c});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),g=s(t),y=i,c=g["".concat(p,".").concat(y)]||g[y]||m[y]||r;return t?a.createElement(c,l(l({ref:n},d),{},{components:t})):a.createElement(c,l({ref:n},d))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=y;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[g]="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},5785:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(8168),i=(t(6540),t(5680));const r={},l="Lab 9 - File Descriptors",o={unversionedId:"IO/lab9",id:"IO/lab9",title:"Lab 9 - File Descriptors",description:"Task: My cat",source:"@site/docs/IO/lab9.md",sourceDirName:"IO",slug:"/IO/lab9",permalink:"/operating-systems/IO/lab9",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Syscall Used by `fopen()`",permalink:"/operating-systems/IO/Questions/fopen-syscall"},next:{title:"Lab 10 - Inter-Process Communication",permalink:"/operating-systems/IO/lab10"}},p={},s=[{value:"Task: My <code>cat</code>",id:"task-my-cat",level:2},{value:"Task: Copy a File with <code>mmap()</code>",id:"task-copy-a-file-with-mmap",level:2},{value:"Task: Anonymous Pipes Communication",id:"task-anonymous-pipes-communication",level:2},{value:"File Descriptors",id:"file-descriptors",level:2},{value:"<code>FILE</code> Operations Explained",id:"file-operations-explained",level:3},{value:"File Descriptor Operations",id:"file-descriptor-operations",level:2},{value:"<code>open()</code>",id:"open",level:3},{value:"<code>close()</code>",id:"close",level:3},{value:"<code>read()</code> and <code>write()</code>",id:"read-and-write",level:3},{value:"<code>lseek()</code>",id:"lseek",level:3},{value:"Pipes",id:"pipes",level:2},{value:"Anonymous Pipes",id:"anonymous-pipes",level:3},{value:"Named Pipes (FIFOs)",id:"named-pipes-fifos",level:3},{value:"Redirections",id:"redirections",level:3},{value:"Guide: Simple File Operations",id:"guide-simple-file-operations",level:2},{value:"Guide: Redirections",id:"guide-redirections",level:2},{value:"<code>dup()/dup2()</code> - Atomic IO",id:"dupdup2---atomic-io",level:3},{value:"Guide: File Descriptor Table",id:"guide-file-descriptor-table",level:2},{value:"Guide: libc <code>FILE</code> struct",id:"guide-libc-file-struct",level:2},{value:"<code>printf()</code> Buffering",id:"printf-buffering",level:3},{value:"Guide: File Mappings",id:"guide-file-mappings",level:2},{value:"File I/O vs <code>mmap()</code>",id:"file-io-vs-mmap",level:3},{value:"Guide: Reading Linux Directories",id:"guide-reading-linux-directories",level:2}],d={toc:s},g="wrapper";function m(e){let{components:n,...r}=e;return(0,i.yg)(g,(0,a.A)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"lab-9---file-descriptors"},"Lab 9 - File Descriptors"),(0,i.yg)("h2",{id:"task-my-cat"},"Task: My ",(0,i.yg)("inlineCode",{parentName:"h2"},"cat")),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/io/file-descriptors/drills/tasks/my-cat/support/src")," and checkout ",(0,i.yg)("inlineCode",{parentName:"p"},"my_cat.c"),".\nWe propose to implement the Linux command ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," that reads one or more files, ",(0,i.yg)("strong",{parentName:"p"},"concatenates")," them (hence the name ",(0,i.yg)("inlineCode",{parentName:"p"},"cat"),"), and prints them to standard output."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Inside the ",(0,i.yg)("inlineCode",{parentName:"li"},"tests/")," directory, you will need to run ",(0,i.yg)("inlineCode",{parentName:"li"},"checker.sh"),". The output for a successful implementation should look like this:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nmake: Nothing to be done for 'all'.\n\nTest 1: Comparing single file output..........................PASSED (+30 points)\nTest 2: Comparing multiple files output.......................PASSED (+30 points)\nTest 3: Testing empty file....................................PASSED (+30 points)\n----------------------------------------\nFinal Score: 100/100 points\nGood job!\n----------------------------------------\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Implement ",(0,i.yg)("inlineCode",{parentName:"p"},"rread()")," wrapper over ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),"."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"read()")," system call does not guarantee that it will read the requested number of bytes in a single call.\nThis happens when the file does not have enough bytes, or when ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," is interrupted by a signal.\n",(0,i.yg)("inlineCode",{parentName:"p"},"rread()")," will handle these situations, ensuring that it reads either ",(0,i.yg)("inlineCode",{parentName:"p"},"num_bytes")," or all available bytes.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Implement ",(0,i.yg)("inlineCode",{parentName:"p"},"wwrite()")," as a wrapper for ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),"."),(0,i.yg)("p",{parentName:"li"},"The ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," system call may not write the requested number of bytes in a single call.\nThis happens if ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," is interrupted by a signal.\n",(0,i.yg)("inlineCode",{parentName:"p"},"wwrite()")," will guarantee that it wrote the full ",(0,i.yg)("inlineCode",{parentName:"p"},"num_bytes"),", retrying as necessary until all data is successfully written or an error occurs.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Implement ",(0,i.yg)("inlineCode",{parentName:"p"},"cat()"),"."),(0,i.yg)("p",{parentName:"li"},"Use ",(0,i.yg)("inlineCode",{parentName:"p"},"rread()")," to read an entire file and ",(0,i.yg)("inlineCode",{parentName:"p"},"wwrite()")," to write the contents to standard output.\nKeep in mind that the buffer size may not fit the entire file at once."))),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#file-descriptors"},"this reading material"),"."),(0,i.yg)("h2",{id:"task-copy-a-file-with-mmap"},"Task: Copy a File with ",(0,i.yg)("inlineCode",{parentName:"h2"},"mmap()")),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"file-descriptors/drills/tasks/mmap_cp")," and run ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," to generate ",(0,i.yg)("inlineCode",{parentName:"p"},"support"),".\nAs you know ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," can map files in memory, perform operations on them, and then write them back to the disk.\nLet's check how well it performs by comparing it to the ",(0,i.yg)("inlineCode",{parentName:"p"},"cp")," command.\nThe benchmarking is automated by ",(0,i.yg)("inlineCode",{parentName:"p"},"benchmark_cp.sh")," so focus on completing ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap_cp.c")," for now."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"Questions/syscalls-cp"},"Quiz: Checkout what syscalls ",(0,i.yg)("inlineCode",{parentName:"a"},"cp")," uses")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Inside the ",(0,i.yg)("inlineCode",{parentName:"li"},"tests/")," directory, you will need to run ",(0,i.yg)("inlineCode",{parentName:"li"},"checker.sh"),". The output for a successful implementation should look like this:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nmake: Nothing to be done for 'all'.\n\nTest PASSED (File copies are identical)\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Open ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap_cp.c")," and complete the TODOs to map the files in memory and copy the contents.\nDo not forget to clean up by unmapping and closing the files."),(0,i.yg)("p",{parentName:"li"},"To test, run ",(0,i.yg)("inlineCode",{parentName:"p"},"make test-file")," to generate a 1MB file with random data, and then run ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap_cp test-file output.txt"),".\nEnsure they have the same content with a simple ",(0,i.yg)("inlineCode",{parentName:"p"},"diff"),": ",(0,i.yg)("inlineCode",{parentName:"p"},"diff test-file.txt output.txt"),".")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Compare your implementation to the ",(0,i.yg)("inlineCode",{parentName:"p"},"cp")," command.\nRun ",(0,i.yg)("inlineCode",{parentName:"p"},"make large-file")," to generate a 1GB file with random data, and then run ",(0,i.yg)("inlineCode",{parentName:"p"},"./benchmark_cp.sh"),"."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"Questions/mmap-read-write-benchmark"},"Quiz: Debunk why ",(0,i.yg)("inlineCode",{parentName:"a"},"cp")," is winning")),(0,i.yg)("p",{parentName:"li"},"If you want a more generic answer, checkout this ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-file-mappings"},"guide on ",(0,i.yg)("inlineCode",{parentName:"a"},"mmap")," vs ",(0,i.yg)("inlineCode",{parentName:"a"},"read()-write()")),".")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"This demo would not be complete without some live analysis.\nUncomment the calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"wait_for_input()")," and rerun the program.\nIn another terminal, run ",(0,i.yg)("inlineCode",{parentName:"p"},"cat /proc/$(pidof mmap_cp)/maps")," to see mapped files, and ",(0,i.yg)("inlineCode",{parentName:"p"},"ps -o pid,vsz,rss <PID>")," to see how demand paging happens."))),(0,i.yg)("h2",{id:"task-anonymous-pipes-communication"},"Task: Anonymous Pipes Communication"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/io/ipc/drills/tasks/anon-pipes")," and run ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," to generate the ",(0,i.yg)("inlineCode",{parentName:"p"},"support/")," folder.\nIn this exercise, you'll implement client-server communication between a parent and a child process using an anonymous pipe.\nThe parent will act as the sender, while the child acts as the receiver, with both processes sharing messages through the pipe.\nSince pipes are unidirectional, each process should close the end of the pipe it does not use."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Inside the ",(0,i.yg)("inlineCode",{parentName:"li"},"tests/")," directory, you will need to run ",(0,i.yg)("inlineCode",{parentName:"li"},"checker.sh"),". The output for a successful implementation should look like this:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nmake: Nothing to be done for 'all'.\n\nTest for short string ........... PASSED\nTest for long string  ........... PASSED\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Use the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man7/pipe.7.html"},(0,i.yg)("inlineCode",{parentName:"a"},"pipe()")," syscall")," to create the pipe.\nRemember, the first file descriptor (",(0,i.yg)("inlineCode",{parentName:"p"},"fds[0]"),") is the read end, and the second (",(0,i.yg)("inlineCode",{parentName:"p"},"fds[1]"),") is the write end, similar to how ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," are represented by file descriptors ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"1"),"."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Hint:")," Use ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," to end the program."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"Questions/pipe-ends"},"Quiz: Discover why you cannot use either end of the pipe for reading or writing"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Solve the TODOs in ",(0,i.yg)("inlineCode",{parentName:"p"},"parent_loop")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"child_loop")," so that the application stops on ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),".\nEnsure each process closes the its pipe end before exiting to prevent indefinite blocking."),(0,i.yg)("blockquote",{parentName:"li"},(0,i.yg)("p",{parentName:"blockquote"},"Why is closing the pipe ends important?")),(0,i.yg)("p",{parentName:"li"},"The child process checks for the end of communication by reading from the pipe and checking for ",(0,i.yg)("inlineCode",{parentName:"p"},"EOF"),", which occurs when the write end is closed.\nWithout closing the write end, the child will block indefinitely in ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),".\nAs for the parent, it will block indefinitely in ",(0,i.yg)("inlineCode",{parentName:"p"},"wait()"),"."))),(0,i.yg)("h2",{id:"file-descriptors"},"File Descriptors"),(0,i.yg)("p",null,"You've most likely had to deal with files in the past.\nThe most common command that works with files is ",(0,i.yg)("inlineCode",{parentName:"p"},"cat"),".\nFor a quick refresher, let's write something to a file, and then read its contents."),(0,i.yg)("p",null,"You\u2019ve likely worked with files before;\nnow it\u2019s time to see what happens behind the scenes.\nThe most common way to read a file in Linux is by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," command.\nFor a quick refresher, let\u2019s do a demo by writing some text to a file and then reading it back."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/$ echo "OS Rullz!"  # Print \'OS Rullz!\'\nOS Rullz!\nstudent@os:~/$ echo "OS Rullz!" > newfile.txt  # redirect the output to newfile.txt\n## Let\'s check the contents of newfile.txt\nstudent@os:~/$ cat newfile.txt\nOS Rullz!\n')),(0,i.yg)("p",null,"If we were to implement this in C, we would use the ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," structure and write something like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'FILE *f = fopen("newfile.txt", "r");\nif (!f) {...} // handle error\n\nchar buf[1024];\nint rc = fread(buf, 1, sizeof(buf), f);\nif (rc < 0) {...} // handle error\n\nprintf("%s\\n", buf);\n')),(0,i.yg)("p",null,"For a complete example, check out this guide on ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-simple-file-operations"},"file operations in C, Python, and Java"),"."),(0,i.yg)("h3",{id:"file-operations-explained"},(0,i.yg)("inlineCode",{parentName:"h3"},"FILE")," Operations Explained"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," structure is not the most straightforward method for performing file operations.\nIt is part of ",(0,i.yg)("inlineCode",{parentName:"p"},"libc")," and functions as a handler for working with files.\nThis is not particular to C, as most programming languages offer similar handlers."),(0,i.yg)("p",null,"Running ",(0,i.yg)("inlineCode",{parentName:"p"},"strace cat newfile.txt")," reveals that ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()")," wraps ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," (or ",(0,i.yg)("inlineCode",{parentName:"p"},"openat"),"), ",(0,i.yg)("inlineCode",{parentName:"p"},"fread()")," wraps ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"fclose()")," wraps ",(0,i.yg)("inlineCode",{parentName:"p"},"close()"),".\nAs you can see, the ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE"),"-related functions are just syscalls prefixed with ",(0,i.yg)("inlineCode",{parentName:"p"},"f-"),"."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"th"},"FILE")," Operation"),(0,i.yg)("th",{parentName:"tr",align:null},"Syscall"),(0,i.yg)("th",{parentName:"tr",align:null},"Description"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"fopen()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/open.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"open()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Opens a file and returns a file pointer.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"fclose()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/close.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"close()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Closes the file associated with the pointer.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"fread()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/read.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"read()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Reads data from the file into a buffer.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"fwrite()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/write.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"write()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Writes data from a buffer to the file.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"fseek()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/lseek.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"lseek()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Moves the file position indicator.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"truncate()")),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("a",{parentName:"td",href:"https://man7.org/linux/man-pages/man2/ftruncate.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ftruncate()"))),(0,i.yg)("td",{parentName:"tr",align:null},"Truncates the file to a specified length.")))),(0,i.yg)("p",null,"The main distinction between ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," operations and their corresponding system calls is that the latter use a ",(0,i.yg)("strong",{parentName:"p"},"file descriptor")," to reference a file.\n",(0,i.yg)("strong",{parentName:"p"},"File descriptors")," are simply indexes into the process's ",(0,i.yg)("strong",{parentName:"p"},"File Descriptor Table"),", which is the list of all currently open files for that process."),(0,i.yg)("p",null,"This concept is not entirely new, as each process has three default channels: ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"stderr"),".\nThese are, in fact, the first three entries in every process\u2019s ",(0,i.yg)("strong",{parentName:"p"},"File Descriptor Table"),"."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"Questions/stderr-fd"},"Quiz: Test your intuition by finding the file descriptor of ",(0,i.yg)("inlineCode",{parentName:"a"},"stderr"))),(0,i.yg)("p",null,"Let's translate our previous example to illustrate how this change affects the implementation:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'int fd = open("newfile.txt", O_RDONLY)\nif (fd < 0) {...} // handle error\n\nchar buf[1024];\nint rc = read(fd, buf, sizeof(buf));  // Not complete, should\'ve used a while loop\nif (rc < 0) {...} // handle error\n\nbuf[rc] = \'\\0\'; // Null-terminate the buffer\nprintf("%s\\n", buf);\n')),(0,i.yg)("p",null,"To better understand the ",(0,i.yg)("strong",{parentName:"p"},"file descriptor")," API, you can either ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#file-descriptor-operations"},"keep reading about file descriptor operations")," or checkout ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-reading-linux-directories"},"this guide on reading Linux directories"),"."),(0,i.yg)("p",null,"If you're interested in understanding how ",(0,i.yg)("inlineCode",{parentName:"p"},"libc")," utilizes file descriptors to simplify common operations, check out ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-libc-file-struct"},"this guide"),"."),(0,i.yg)("h2",{id:"file-descriptor-operations"},"File Descriptor Operations"),(0,i.yg)("p",null,"File descriptors are the primary means of referencing files in our system.\nThey are created, deleted, and manipulated through file interface operations, namely ",(0,i.yg)("inlineCode",{parentName:"p"},"open()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"lseek()"),".\nFrom a programmer's perspective, file descriptors are simply indexes into the process's ",(0,i.yg)("strong",{parentName:"p"},"File Descriptor Table"),", which maintains a list of all currently open files for that process."),(0,i.yg)("p",null,"In this section, we will focus on how to utilize file descriptors to perform the same operations that ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," allows, and more.\nIf you want to delve deeper into file descriptors, we recommend exploring ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-file-descriptor-table"},"this guide on the ",(0,i.yg)("strong",{parentName:"a"},"File Descriptor Table")),"."),(0,i.yg)("h3",{id:"open"},(0,i.yg)("inlineCode",{parentName:"h3"},"open()")),(0,i.yg)("p",null,"All processes start with three default file descriptors, inherited from the process's parent:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"stdin")," (standard input): 0"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"stdout")," (standard output): 1"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"stderr")," (standard error): 2")),(0,i.yg)("p",null,"To create new file descriptors (i.e. open new files), a process can use the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/open.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"open()"))," system call.\nIt receives the path to the file, some flags which are akin to the ",(0,i.yg)("inlineCode",{parentName:"p"},"mode")," string passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()"),".\nAn optional ",(0,i.yg)("inlineCode",{parentName:"p"},"mode")," parameter that denotes the file's permissions if the ",(0,i.yg)("inlineCode",{parentName:"p"},"open")," must create it can also be provided.\nIf you use ",(0,i.yg)("inlineCode",{parentName:"p"},"O_CREAT"),", just remember to also pass ",(0,i.yg)("inlineCode",{parentName:"p"},"0644")," (",(0,i.yg)("inlineCode",{parentName:"p"},"rw-r--r--")," in octal, denoted by the first ",(0,i.yg)("inlineCode",{parentName:"p"},"0"),"), or permissions more restrictive."),(0,i.yg)("p",null,"Some other useful flags for ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," are:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"O_APPEND"),": place file cursor at the end"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"O_CLOEXEC"),": close the file descriptor when ",(0,i.yg)("inlineCode",{parentName:"li"},"exec()")," is called.\nThis is useful because child processes inherit the file descriptors, and this can lead to security problems."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"O_TRUNC"),": truncate the file to length 0.")),(0,i.yg)("h3",{id:"close"},(0,i.yg)("inlineCode",{parentName:"h3"},"close()")),(0,i.yg)("p",null,"Once you are done with a file descriptor you should call ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," to free its ",(0,i.yg)("strong",{parentName:"p"},"open file structure"),".\nThis is similar to how you free memory once you are done with it."),(0,i.yg)("h3",{id:"read-and-write"},(0,i.yg)("inlineCode",{parentName:"h3"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"h3"},"write()")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"read_bytes = read(fd, buf, num_bytes);\nwritten_bytes = write(fd, buf, num_bytes);\n")),(0,i.yg)("p",null,"As you know, verifying the return code of system calls is the way to go in general.\nThis is even more apparent when dealing with I/O syscalls, namely ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),", which return the number of bytes read or written."),(0,i.yg)("p",null,"Syscalls returning the number of bytes might seem redundant, but once you hear about partial I/O operations, it is of utmost importance.\nIf your process was interrupted by a signal while reading or writing, it is up to you to continue from where it left off."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Remember: It is mandatory that we always use ",(0,i.yg)("inlineCode",{parentName:"strong"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"strong"},"write()")," inside ",(0,i.yg)("inlineCode",{parentName:"strong"},"while")," loops."),"\nHigher-level functions like ",(0,i.yg)("inlineCode",{parentName:"p"},"fread()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"fwrite()")," also use ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loops when calling ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," respectively.\nYou can practice this by ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#task-my-cat"},"implementing your own ",(0,i.yg)("inlineCode",{parentName:"a"},"cat")," command"),"."),(0,i.yg)("p",null,"In the following sections, we'll use file descriptors and ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," to interact with some inter-process-communication mechanisms, such as pipes."),(0,i.yg)("h3",{id:"lseek"},(0,i.yg)("inlineCode",{parentName:"h3"},"lseek()")),(0,i.yg)("p",null,"As you know, reading or writing from a file always continues from where it left off.\nMost of the time you would read from a file monotonically so it makes sense to keep the interface clean and handle bookkeeping in the back."),(0,i.yg)("p",null,"For cases when you selectively update the file or jump around fetching data, or making updates, we have ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/lseek.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"lseek")),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"off_t lseek(int fd, off_t offset, int whence);\n")),(0,i.yg)("p",null,"Its parameters are pretty intuitive: ",(0,i.yg)("inlineCode",{parentName:"p"},"fd")," stands for the file descriptor and ",(0,i.yg)("inlineCode",{parentName:"p"},"offset")," stands for the offset.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"whence")," directive explains what ",(0,i.yg)("inlineCode",{parentName:"p"},"offset")," is relative to, and has the following values:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"SEEK_SET"),": the file offset is set to offset bytes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"SEEK_CUR"),": The file offset is set to its current location plus offset bytes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"SEEK_END"),": the file offset is set to the size of the file plus offset bytes.")),(0,i.yg)("h2",{id:"pipes"},"Pipes"),(0,i.yg)("h3",{id:"anonymous-pipes"},"Anonymous Pipes"),(0,i.yg)("p",null,"In this session, we'll explore a new mean of Inter-Process Communication (IPC), namely ",(0,i.yg)("strong",{parentName:"p"},"the pipes"),".\nPipes are by no means something new, and you most probably played with them already in bash:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"cat 'log_*.csv' | tr -s ' ' | cut -d ',' -f 2 | sort -u | head -n 10\n")),(0,i.yg)("p",null,"Using pipes (denoted as ",(0,i.yg)("inlineCode",{parentName:"p"},"|")," in the above example) enables linking the ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," of multiple processes.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," of ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," is the ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," of ",(0,i.yg)("inlineCode",{parentName:"p"},"tr"),", whose ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," is the ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," of ",(0,i.yg)("inlineCode",{parentName:"p"},"cut"),' and so on.\nThis "chain" of commands looks like this:'),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Piped Commands",src:t(9234).A})),(0,i.yg)("p",null,"So here we have a ",(0,i.yg)("strong",{parentName:"p"},"unidirectional")," stream of data that starts from ",(0,i.yg)("inlineCode",{parentName:"p"},"cat"),", is modified by each new command, and then is passed to the next one.\nWe can tell from the image above that the communication channel between any 2 adjacent commands allows one process to write to it while the other reads from it.\nFor example, there is no need for ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," to read any of ",(0,i.yg)("inlineCode",{parentName:"p"},"tr"),"'s output, only vice versa."),(0,i.yg)("p",null,"In UNIX, the need for such a channel is fulfilled by the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/pipe.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"pipe()")," syscall"),".\nImagine there's a literal pipe between any 2 adjacent commands in the image above, where data is what flows through this pipe ",(0,i.yg)("strong",{parentName:"p"},"in only a single way"),"."),(0,i.yg)("p",null,"Such pipes are known as ",(0,i.yg)("strong",{parentName:"p"},"anonymous pipes")," because they don\u2019t have identifiers.\nThey are created by a parent process, which shares them with its children.\nData written to an anonymous pipe is stored in a kernel-managed circular buffer, where it\u2019s available for related-processes to read."),(0,i.yg)("p",null,"The following example showcases a typical workflow with anonymous pipes in Unix:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'##define EXIT_ON_COND(cond) do { if (cond) exit(EXIT_FAILURE); } while (0)\n\n// pipe_fd[0] -> for reading\n// pipe_fd[1] -> for writing\nint pipe_fd[2];\n\nEXIT_ON_COND(pipe(pipe_fd) < 0);    // Create the pipe\n\nint pid = fork();                   // Fork to create a child process\nEXIT_ON_COND(pid < 0);              // Check for fork() failure\n\nif (pid == 0) {  // Child process\n    EXIT_ON_COND(close(pipe_fd[0]) != 0);           // Close the read end\n    EXIT_ON_COND(write(pipe_fd[1], "hi", 2) < 0);   // Write "hi" to the pipe\n    EXIT_ON_COND(close(pipe_fd[1]) != 0);           // Close the write end\n} else {          // Parent process\n    char buf[BUFSIZ];\n\n    EXIT_ON_COND(close(pipe_fd[1]) != 0);           // Close the write end\n    ssize_t n = read(pipe_fd[0], buf, sizeof(buf)); // Read data from the pipe into buf\n    EXIT_ON_COND(n < 0);                            // Check for read() failure\n\n    buf[n] = \'\\0\';                                  // Null-terminate the string\n    printf("Received: %s\\n", buf);                  // Output the received message\n}\n')),(0,i.yg)("p",null,"In summary, the process creates the pipe and then calls ",(0,i.yg)("inlineCode",{parentName:"p"},"fork()")," to create a child process.\nBy default, the file descriptors created by ",(0,i.yg)("inlineCode",{parentName:"p"},"pipe()")," are shared with the child because the ",(0,i.yg)("em",{parentName:"p"},"(file descriptor table)")," is copied upon creation.\nTo better understand how this works, please refer to ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-file-descriptor-table"},"this guide on the File Descriptor Table (FDT)"),"."),(0,i.yg)("p",null,"You can test your understanding of anonymous pipes by completing the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#task-anonymous-pipes-communication"},"Anonymous Pipes Communication task"),"."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"Questions/anonymous-pipes-limitation"},"Check your understanding by identifying the limitations of anonymous pipes")),(0,i.yg)("h3",{id:"named-pipes-fifos"},"Named Pipes (FIFOs)"),(0,i.yg)("p",null,"As we discussed, anonymous pipes are named so because they lack identifiers.\n",(0,i.yg)("strong",{parentName:"p"},"Named pipes")," address this limitation by creating a ",(0,i.yg)("em",{parentName:"p"},"special")," file on disk that serves as an identifier for the pipe."),(0,i.yg)("p",null,"You might think that interacting with a file would result in a performance loss compared to anonymous pipes, but this is not the case.\nThe FIFO file acts merely as ",(0,i.yg)("strong",{parentName:"p"},"a handler")," within the filesystem, which is used to write data to a buffer inside the kernel.\nThis buffer is responsible for holding the data that is passed between processes, not the filesystem itself."),(0,i.yg)("p",null,"Keep in mind that reading from and writing to a FIFO is not the same as interacting with a regular file - ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," will block if the pipe is empty and will return ",(0,i.yg)("inlineCode",{parentName:"p"},"EOF")," when the peer closes the pipe."),(0,i.yg)("p",null,"You can practice working with named pipes by completing the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab10#task-named-pipes-communication"},"Named Pipes Communication task"),"."),(0,i.yg)("h3",{id:"redirections"},"Redirections"),(0,i.yg)("p",null,"Although not directly related, redirections (e.g., ",(0,i.yg)("inlineCode",{parentName:"p"},"ls > file.txt"),") operate similarly to pipes.\nA process creates a new file descriptor, updates its ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout"),", and then creates the child process.\nYou can explore the similarities with pipes further in ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-redirections"},"this guide on redirections"),"."),(0,i.yg)("h2",{id:"guide-simple-file-operations"},"Guide: Simple File Operations"),(0,i.yg)("p",null,"To manipulate the file (read its contents, modify them, change its size etc.), each process must first get a ",(0,i.yg)("strong",{parentName:"p"},"handler")," to this file.\nThink of this handler as an object by which the process can identify and refer to the file."),(0,i.yg)("p",null,"Now take a look at the code examples in ",(0,i.yg)("inlineCode",{parentName:"p"},"file-descriptors/guides/simple-file-operations/support"),".\nEach of them reads the contents of ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt"),", modifies them, and then reads the previously modified file again.\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," to compile the C code, and ",(0,i.yg)("inlineCode",{parentName:"p"},"make java-file-operations")," to compile the Java code."),(0,i.yg)("p",null,"Now run the programs repeatedly in whatever order you wish:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../simple-file-operations/support$ python3 file_operations.py\nFile contents are: OS Rullz!\nWrote new data to file\nFile contents are: Python was here!\n\nstudent@os:~/.../simple-file-operations/support$ ./file_operations  # from the C code\nFile contents are: Python was here!\nWrote new data to file\nFile contents are: C was here!\n\nstudent@os:~/.../simple-file-operations/support$ java FileOperations\nFile contents are: Python was here!\nWrote new data to file\nFile contents are: Java was here!\n")),(0,i.yg)("p",null,"Note that each piece of code creates a variable, which is then used as a handler."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"Questions/file-handler-c"},"Quiz")),(0,i.yg)("h2",{id:"guide-redirections"},"Guide: Redirections"),(0,i.yg)("p",null,"In the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#file-descriptors"},"File Descriptors section"),", we mentioned redirections such as ",(0,i.yg)("inlineCode",{parentName:"p"},'echo "OS Rullz!" > newfile.txt'),".\nWe said ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt")," has to be opened at some point.\nLet\u2019s explore the relevant system calls (",(0,i.yg)("inlineCode",{parentName:"p"},"open()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"openat()"),") to see this in action:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../guides/redirections$ strace -e trace=open,openat,execve,dup2 -f sh -c "ls > file.txt"\nexecve("/usr/bin/sh", ["sh", "-c", "ls > file.txt"], 0x7fffe1383e78 /* 36 vars */) = 0\nopenat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3\nopenat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3\nopenat(AT_FDCWD, "file.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3\ndup2(3, 1)                              = 1\nstrace: Process 77547 attached\n[pid 77547] execve("/usr/bin/ls", ["ls"], 0x55ebb9b2dbf8 /* 36 vars */) = 0\n[...]\n')),(0,i.yg)("p",null,"Notice that we used ",(0,i.yg)("inlineCode",{parentName:"p"},"sh -c")," to run ",(0,i.yg)("inlineCode",{parentName:"p"},"ls > file.txt"),".\nRunning ",(0,i.yg)("inlineCode",{parentName:"p"},"strace -e trace=open,openat,execve,dup2 -f ls > file.txt")," would instead redirect the ",(0,i.yg)("inlineCode",{parentName:"p"},"strace")," output to ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt"),", hiding any system calls related to ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt"),".\nThis happens because, as we discussed earlier, redirection is transparent for the process being redirected.\nThe process still writes to its ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout"),", but ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," itself is now directed to the specified file."),(0,i.yg)("p",null,"Remember how processes are created using ",(0,i.yg)("inlineCode",{parentName:"p"},"fork()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"exec()"),", as shown in this diagram:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Launching a new command in Bash",src:t(5973).A})),(0,i.yg)("p",null,"In our case, the main process is ",(0,i.yg)("inlineCode",{parentName:"p"},'sh -c "ls > file.txt"'),".\nIn the ",(0,i.yg)("inlineCode",{parentName:"p"},"strace")," output, we see it opens ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt")," on file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"3"),", then uses ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/dup.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"dup2(3, 1)"))," to redirect file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"1")," to the same ",(0,i.yg)("strong",{parentName:"p"},"open file structure"),".\nIt then ",(0,i.yg)("strong",{parentName:"p"},"forks")," a child process and calls ",(0,i.yg)("inlineCode",{parentName:"p"},"execve()"),"."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"execve")," replaces the virtual address space (VAS) of the current process but retains the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-file-descriptor-table"},"file descriptor table"),".\nThis preserve the ",(0,i.yg)("inlineCode",{parentName:"p"},"stdout")," of the parent process, thus the redirection to ",(0,i.yg)("inlineCode",{parentName:"p"},"file.txt")," remains effective in the new process as well."),(0,i.yg)("h3",{id:"dupdup2---atomic-io"},(0,i.yg)("inlineCode",{parentName:"h3"},"dup()/dup2()")," - Atomic IO"),(0,i.yg)("p",null,"If you're not familiar with the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/dup.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"dup()")," syscall"),", it essentially creates a new file descriptor pointing to an existing ",(0,i.yg)("strong",{parentName:"p"},"open file structure"),".\nUnlike ",(0,i.yg)("inlineCode",{parentName:"p"},"open()"),", as discussed in the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#guide-file-descriptor-table"},"file descriptor table guide"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"dup()")," doesn\u2019t create a fresh open file structure."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"dup2(old_fd, new_fd)")," variant closes ",(0,i.yg)("inlineCode",{parentName:"p"},"new_fd")," before making it point to the same open file structure as ",(0,i.yg)("inlineCode",{parentName:"p"},"old_fd"),".\nWhile this might seem like a combination of ",(0,i.yg)("inlineCode",{parentName:"p"},"close(new_fd)")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"open(old_fd)"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"dup2()")," is actually atomic, which prevents race conditions."),(0,i.yg)("p",null,"To see why atomicity matters, review the code in ",(0,i.yg)("inlineCode",{parentName:"p"},"support/redirect_parallel.c"),", compile it, and run it."),(0,i.yg)("p",null,"You\u2019ll find that ",(0,i.yg)("inlineCode",{parentName:"p"},"redirect_stderr_file.txt")," contains ",(0,i.yg)("inlineCode",{parentName:"p"},"Message for STDOUT"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"redirect_stdout_file.txt")," contains ",(0,i.yg)("inlineCode",{parentName:"p"},"Message for STDERR"),".\nInvestigate the code to understand where the race condition occurred."),(0,i.yg)("p",null,"While a ",(0,i.yg)("inlineCode",{parentName:"p"},"mutex")," around the ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," sequence could fix this, it can make the code cumbersome.\nInstead, follow the ",(0,i.yg)("inlineCode",{parentName:"p"},"FIXME")," comments for a more elegant solution using ",(0,i.yg)("inlineCode",{parentName:"p"},"dup2()"),"."),(0,i.yg)("h2",{id:"guide-file-descriptor-table"},"Guide: File Descriptor Table"),(0,i.yg)("p",null,"Just as each process has its own Virtual Address Space for memory access, it also maintains its own ",(0,i.yg)("strong",{parentName:"p"},"File Descriptor Table")," (FDT) for managing open files.\nIn this section we will explore how the process structures change when executing syscalls like ",(0,i.yg)("inlineCode",{parentName:"p"},"open()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"close()"),"."),(0,i.yg)("p",null,"Upon startup, every process has three ",(0,i.yg)("strong",{parentName:"p"},"file descriptors")," that correspond to standard input (",(0,i.yg)("inlineCode",{parentName:"p"},"stdin"),"), standard output (",(0,i.yg)("inlineCode",{parentName:"p"},"stdout"),"), and standard error (",(0,i.yg)("inlineCode",{parentName:"p"},"stderr"),").\nThese descriptors are inherited from the parent process and occupy the ",(0,i.yg)("strong",{parentName:"p"},"first three")," entries in the process's ",(0,i.yg)("strong",{parentName:"p"},"FDT"),"."),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"fd"),(0,i.yg)("th",{parentName:"tr",align:null},"Open File Struct"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"0"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"stdin"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"1"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"stdout"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"2"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"stderr"))))),(0,i.yg)("p",null,"Each entry ",(0,i.yg)("strong",{parentName:"p"},"points to")," an ",(0,i.yg)("strong",{parentName:"p"},"open file structure")," which stores data about the current session:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Permissions"),": define how the file can be accessed (read, write, or execute);\nthese are the options passed to ",(0,i.yg)("inlineCode",{parentName:"li"},"open()"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Offset"),": the current position inside the file from which the next read or write operation will occur."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Reference Count"),": The number of file descriptors referencing this open file structure."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Inode Pointer"),": A pointer to the inode structure that contains both the data and metadata associated with the file.")),(0,i.yg)("p",null,"These ",(0,i.yg)("strong",{parentName:"p"},"Open File Structures")," are held in the ",(0,i.yg)("strong",{parentName:"p"},"Open File Table (OFT)"),", which is global across the system.\nWhenever a new file is opened, a new entry is created in this table."),(0,i.yg)("p",null,"To illustrate this, let's consider a code snippet and examine how the File Descriptor Table and Open File Table would appear.\nWe will focus on ",(0,i.yg)("inlineCode",{parentName:"p"},"fd"),", permissions, offset, and reference count, as the inode pointer is not relevant at this moment.\nFor simplicity, we'll also omit the standard file descriptors, as they remain unchanged."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'int fd = open("file.txt", O_RDONLY);\nint fd2 = open("file2.txt", O_WRONLY | O_APPEND);\nint fd3 = open("file.txt", O_RDWR);\n')),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"OFT index"),(0,i.yg)("th",{parentName:"tr",align:null},"Path"),(0,i.yg)("th",{parentName:"tr",align:null},"Perm"),(0,i.yg)("th",{parentName:"tr",align:null},"Off"),(0,i.yg)("th",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"th"},"RefCount")))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"...")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"123"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"r--"),(0,i.yg)("td",{parentName:"tr",align:null},"0"),(0,i.yg)("td",{parentName:"tr",align:null},"1")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"140"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file2.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"-w-"),(0,i.yg)("td",{parentName:"tr",align:null},"150"),(0,i.yg)("td",{parentName:"tr",align:null},"1")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"142"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"rw-"),(0,i.yg)("td",{parentName:"tr",align:null},"0"),(0,i.yg)("td",{parentName:"tr",align:null},"1")))),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"fd"),(0,i.yg)("th",{parentName:"tr",align:null},"Open File Struct (OFT index)"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"3"),(0,i.yg)("td",{parentName:"tr",align:null},"123")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"4"),(0,i.yg)("td",{parentName:"tr",align:null},"140")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"5"),(0,i.yg)("td",{parentName:"tr",align:null},"142")))),(0,i.yg)("p",null,"Let's discuss the changes from the OFT and FDT to understand what happened:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},'open("file.txt", O_RDONLY)')," created a new ",(0,i.yg)("strong",{parentName:"li"},"open file structure")," in the ",(0,i.yg)("strong",{parentName:"li"},"Open File Table")," for ",(0,i.yg)("inlineCode",{parentName:"li"},"file.txt"),".\nThe entry has read-only (",(0,i.yg)("inlineCode",{parentName:"li"},"O_RDONLY"),") permissions and offset ",(0,i.yg)("inlineCode",{parentName:"li"},"0"),", representing the start of the file.\nSubsequently, file descriptor ",(0,i.yg)("inlineCode",{parentName:"li"},"3")," was assigned to point to this OFT entry, and the reference counter was set to ",(0,i.yg)("inlineCode",{parentName:"li"},"1"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},'open("file2.txt", O_WRONLY)')," created a similar structure in the OFT for ",(0,i.yg)("inlineCode",{parentName:"li"},"file2.txt"),", but with write-only (",(0,i.yg)("inlineCode",{parentName:"li"},"O_WRONLY"),") permissions and an offset of ",(0,i.yg)("inlineCode",{parentName:"li"},"150"),", representing the end of the file (",(0,i.yg)("inlineCode",{parentName:"li"},"O_APPEND"),").\nIt then assigned this entry to file descriptor ",(0,i.yg)("inlineCode",{parentName:"li"},"4"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},'open("file.txt", O_RDWR)')," created a new ",(0,i.yg)("strong",{parentName:"li"},"open file structure")," for ",(0,i.yg)("inlineCode",{parentName:"li"},"file.txt")," and assigned it to file descriptor ",(0,i.yg)("inlineCode",{parentName:"li"},"5"),".")),(0,i.yg)("p",null,"At this point, one might wonder why the last ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," call didn't reuse the entry at file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"3")," and increase its reference counter instead.\nIt might seem logical, but doing so would lead to conflicts with the ",(0,i.yg)("strong",{parentName:"p"},"permissions")," and ",(0,i.yg)("strong",{parentName:"p"},"offset")," of the two open file structures.\n",(0,i.yg)("strong",{parentName:"p"},"Remember:")," each ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," call creates a new ",(0,i.yg)("strong",{parentName:"p"},"open file structure")," in the ",(0,i.yg)("strong",{parentName:"p"},"Open File Table"),"."),(0,i.yg)("p",null,"This raises the question about the necessity for a reference counter.\nThe short answer is ",(0,i.yg)("inlineCode",{parentName:"p"},"dup()")," (or ",(0,i.yg)("inlineCode",{parentName:"p"},"dup2()"),") syscall, which duplicates a file descriptor.\nLet's continue our previous example with the following snippet:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"// fd = 3 (from the previous snippet)\nint fd4 = dup(fd);\n")),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"OFT index"),(0,i.yg)("th",{parentName:"tr",align:null},"Path"),(0,i.yg)("th",{parentName:"tr",align:null},"Perm"),(0,i.yg)("th",{parentName:"tr",align:null},"Offset"),(0,i.yg)("th",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"th"},"RefCount")))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"..."),(0,i.yg)("td",{parentName:"tr",align:null},"...")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"123"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"r--"),(0,i.yg)("td",{parentName:"tr",align:null},"0"),(0,i.yg)("td",{parentName:"tr",align:null},"2")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"140"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file2.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"-w-"),(0,i.yg)("td",{parentName:"tr",align:null},"150"),(0,i.yg)("td",{parentName:"tr",align:null},"1")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"142"),(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"file.txt")),(0,i.yg)("td",{parentName:"tr",align:null},"rw-"),(0,i.yg)("td",{parentName:"tr",align:null},"0"),(0,i.yg)("td",{parentName:"tr",align:null},"1")))),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"fd"),(0,i.yg)("th",{parentName:"tr",align:null},"Open File Struct (OFT index)"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"3"),(0,i.yg)("td",{parentName:"tr",align:null},"123")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"4"),(0,i.yg)("td",{parentName:"tr",align:null},"140")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"5"),(0,i.yg)("td",{parentName:"tr",align:null},"142")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"6"),(0,i.yg)("td",{parentName:"tr",align:null},"123")))),(0,i.yg)("p",null,"The call to ",(0,i.yg)("inlineCode",{parentName:"p"},"dup(fd)")," created a new file descriptor (",(0,i.yg)("inlineCode",{parentName:"p"},"6"),") that points to the same ",(0,i.yg)("strong",{parentName:"p"},"open file structure")," as its argument ",(0,i.yg)("inlineCode",{parentName:"p"},"fd")," (which equals ",(0,i.yg)("inlineCode",{parentName:"p"},"3")," in our example).\nThis operation also incremented the reference counter for the entry ",(0,i.yg)("inlineCode",{parentName:"p"},"123")," in the ",(0,i.yg)("strong",{parentName:"p"},"Open File Table"),"."),(0,i.yg)("p",null,"As a result, operations performed on file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"3")," and file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"6")," are equivalent.\nFor instance, ",(0,i.yg)("inlineCode",{parentName:"p"},"read(3)")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"read(6)")," will both increment the shared file offset, while the offset of file descriptor ",(0,i.yg)("inlineCode",{parentName:"p"},"5")," will remain unchanged.\nIf you want to see a concrete example of when duplicating file descriptors is useful, check out ",(0,i.yg)("inlineCode",{parentName:"p"},"file-descriptors/guides/fd-table/support/redirect-stdout.c"),"."),(0,i.yg)("p",null,"Now that you know how to create entries in the ",(0,i.yg)("strong",{parentName:"p"},"File Descriptor Table")," and the ",(0,i.yg)("strong",{parentName:"p"},"Open File Table"),", it\u2019s important to understand how to remove them.\nCalling ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," will ",(0,i.yg)("strong",{parentName:"p"},"always")," free a file descriptor, but it will ",(0,i.yg)("strong",{parentName:"p"},"only decrement")," the reference counter of the ",(0,i.yg)("strong",{parentName:"p"},"open file structure"),".\nThe actual closing of the file occurs when the reference counter reaches ",(0,i.yg)("inlineCode",{parentName:"p"},"0"),"."),(0,i.yg)("h2",{id:"guide-libc-file-struct"},"Guide: libc ",(0,i.yg)("inlineCode",{parentName:"h2"},"FILE")," struct"),(0,i.yg)("p",null,"Now, we will take a short look at how the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#file-descriptors"},"file descriptors")," are handled in libc.\nThe Software Stack chapter has taught us that applications generally interact with libraries which expose wrappers on top of syscalls.\nThe most important library in a POSIX system (such as Linux) is libc.\nAmong many others, it provides higher-level abstractions over I/O-related syscalls."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Musl"),' (read just like "muscle") is a lightweight implementation of libc, which exposes the same API that you have used so far, while also being fit for embedded and OS development.\nFor example, ',(0,i.yg)("a",{parentName:"p",href:"https://unikraft.org/"},"Unikraft")," ",(0,i.yg)("a",{parentName:"p",href:"https://unikraft.org/docs/concepts/"},"unikernels")," may ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/unikraft/lib-musl"},"use musl"),"."),(0,i.yg)("p",null,"First, it provides a ",(0,i.yg)("inlineCode",{parentName:"p"},"struct")," that groups together multiple data that is necessary when handling files.\nWe know from the example in ",(0,i.yg)("inlineCode",{parentName:"p"},"support/simple-file-operations/file_operations.c")," that the file handler employed by libc is ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE *"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," is just a ",(0,i.yg)("inlineCode",{parentName:"p"},"typedef")," for ",(0,i.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/internal/stdio_impl.h#L21"},(0,i.yg)("inlineCode",{parentName:"a"},"struct _IO_FILE")),".\nHere are the most important fields in ",(0,i.yg)("inlineCode",{parentName:"p"},"struct _IO_FILE"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"struct _IO_FILE {\n    int fd;         /* File descriptor */\n\n    unsigned flags; /* Flags with which `open()` was called */\n\n    int mode;       /* File permissions; passed to `open()` */\n\n    off_t off;      /* File offset from where to read / write */\n\n    /**\n     * Internal buffer used to make fewer costly `read()`/`write()`\n     * syscalls.\n     */\n    unsigned char *buf;\n    size_t buf_size;\n\n    /* Pointers for reading and writing from/to the buffer defined above. */\n    unsigned char *rpos, *rend;\n    unsigned char *wend, *wpos;\n\n    /* Function pointers to syscall wrappers. */\n    size_t (*read)(FILE *, unsigned char *, size_t);\n    size_t (*write)(FILE *, const unsigned char *, size_t);\n    off_t (*seek)(FILE *, off_t, int);\n    int (*close)(FILE *);\n\n    /* Lock for concurrent file access. */\n    volatile int lock;\n};\n")),(0,i.yg)("p",null,"As you might have imagined, this structure contains the underlying file descriptor, the ",(0,i.yg)("inlineCode",{parentName:"p"},"mode")," (read, write, truncate etc.) with which the file was opened, as well as the offset within the file from which the next read / write will start."),(0,i.yg)("p",null,"Libc also defines its own wrappers over commonly-used syscalls, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"lseek()"),".\nThese syscalls themselves need to be implemented by the driver for each file system.\nThis is done by writing the required functions for each syscall and then populating ",(0,i.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.0.9/source/include/linux/fs.h#L2093"},"this structure")," with pointers to them.\nYou will recognise quite a few syscalls: ",(0,i.yg)("inlineCode",{parentName:"p"},"open()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"close()")," ",(0,i.yg)("inlineCode",{parentName:"p"},"read()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"write()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," etc."),(0,i.yg)("h3",{id:"printf-buffering"},(0,i.yg)("inlineCode",{parentName:"h3"},"printf()")," Buffering"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"buffering/support/printf_buffering.c"),".\nThose ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," calls obviously end up calling ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," at some point.\nRun the code under ",(0,i.yg)("inlineCode",{parentName:"p"},"strace"),"."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"Questions/strace-printf"},"Quiz: What syscall does ",(0,i.yg)("inlineCode",{parentName:"a"},"printf")," use?")),(0,i.yg)("p",{parentName:"li"},"Since there is only one ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," syscall despite multiple calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()"),", it means that the strings given to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," as arguments are kept ",(0,i.yg)("em",{parentName:"p"},"somewhere")," until the syscall is made.\nThat ",(0,i.yg)("em",{parentName:"p"},"somewhere")," is precisely that buffer inside ",(0,i.yg)("inlineCode",{parentName:"p"},"struct _IO_FILE")," that we highlighted above.\nRemember that syscalls cause the system to change from user mode to kernel mode, which is time-consuming.\nInstead of performing one ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," syscall per call to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()"),", it is more efficient to copy the string passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," to an ",(0,i.yg)("strong",{parentName:"p"},"internal buffer")," inside libc (the ",(0,i.yg)("inlineCode",{parentName:"p"},"unsigned char *buf")," from above) and then at a given time (like when the buffer is full for example) ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," the whole buffer.\nThis results in far fewer ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," syscalls.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Now, it is interesting to see how we can force libc to dump that internal buffer.\nThe most direct way is by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"fflush()")," library call, which is made for this exact purpose.\nBut we can be more subtle.\nAdd a ",(0,i.yg)("inlineCode",{parentName:"p"},"\\n")," in some of the strings printed in ",(0,i.yg)("inlineCode",{parentName:"p"},"buffering/support/printf_buffering.c"),".\nPlace them wherever you want (at the beginning, at the end, in the middle).\nRecompile the code and observe its change in behaviour under ",(0,i.yg)("inlineCode",{parentName:"p"},"strace"),"."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"Questions/flush-libc-buffer"},"Quiz: How to get data out of ",(0,i.yg)("inlineCode",{parentName:"a"},"printf"),"'s buffer?")),(0,i.yg)("p",{parentName:"li"},"Now we know that I/O buffering ",(0,i.yg)("strong",{parentName:"p"},"does happen")," within libc.\nIf you need further convincing, check out the Musl implementation of ",(0,i.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/stdio/fread.c#L6"},(0,i.yg)("inlineCode",{parentName:"a"},"fread()")),", for example.\nIt first copies the ",(0,i.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/stdio/fread.c#L16"},"data previously saved in the internal buffer"),":"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-c"},"if (f->rpos != f->rend) {\n    /* First exhaust the buffer. */\n    k = MIN(f->rend - f->rpos, l);\n    memcpy(dest, f->rpos, k);\n    f->rpos += k;\n    dest += k;\n    l -= k;\n}\n")),(0,i.yg)("p",{parentName:"li"},"Then, if more data is requested and the internal buffer isn't full, it refills it using ",(0,i.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/stdio/fread.c#L27"},"the internal ",(0,i.yg)("inlineCode",{parentName:"a"},"read()")," wrapper"),".\nThis wrapper also places the data inside the destination buffer."))),(0,i.yg)("h2",{id:"guide-file-mappings"},"Guide: File Mappings"),(0,i.yg)("p",null,"Mapping a file to the VAS of a process is similar to how shared libraries are loaded into the same VAS.\nIt's a fancier way of saying that the contents of a file are copied from a given offset within that file to a given address.\nWhat's nice about this is that the OS handles all offsets, addresses and memory allocations on its own, with a single highly versatile syscall: ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()"),"."),(0,i.yg)("p",null,"Let's run a ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," process and inspect its memory zones:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~$ sleep 1000 &  # start a `sleep` process in the background\n[1] 17579\n\nstudent@os:~$ cat /proc/$(pidof sleep)/maps\n55b7b646f000-55b7b6471000 r--p 00000000 103:07 6423964                   /usr/bin/sleep\n55b7b6471000-55b7b6475000 r-xp 00002000 103:07 6423964                   /usr/bin/sleep\n55b7b6475000-55b7b6477000 r--p 00006000 103:07 6423964                   /usr/bin/sleep\n55b7b6478000-55b7b6479000 r--p 00008000 103:07 6423964                   /usr/bin/sleep\n55b7b6479000-55b7b647a000 rw-p 00009000 103:07 6423964                   /usr/bin/sleep\n55b7b677c000-55b7b679d000 rw-p 00000000 00:00 0                          [heap]\n7fe442f61000-7fe44379d000 r--p 00000000 103:07 6423902                   /usr/lib/locale/locale-archive\n7fe44379d000-7fe4437bf000 r--p 00000000 103:07 6432810                   /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7fe4437bf000-7fe443937000 r-xp 00022000 103:07 6432810                   /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7fe443937000-7fe443985000 r--p 0019a000 103:07 6432810                   /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7fe443985000-7fe443989000 r--p 001e7000 103:07 6432810                   /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7fe443989000-7fe44398b000 rw-p 001eb000 103:07 6432810                   /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7fe44398b000-7fe443991000 rw-p 00000000 00:00 0\n7fe4439ad000-7fe4439ae000 r--p 00000000 103:07 6429709                   /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7fe4439ae000-7fe4439d1000 r-xp 00001000 103:07 6429709                   /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7fe4439d1000-7fe4439d9000 r--p 00024000 103:07 6429709                   /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7fe4439da000-7fe4439db000 r--p 0002c000 103:07 6429709                   /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7fe4439db000-7fe4439dc000 rw-p 0002d000 103:07 6429709                   /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7fe4439dc000-7fe4439dd000 rw-p 00000000 00:00 0\n7ffd07aeb000-7ffd07b0c000 rw-p 00000000 00:00 0                          [stack]\n7ffd07b8b000-7ffd07b8e000 r--p 00000000 00:00 0                          [vvar]\n7ffd07b8e000-7ffd07b8f000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\n")),(0,i.yg)("p",null,"In the output above, you can see that the ",(0,i.yg)("inlineCode",{parentName:"p"},".text"),", ",(0,i.yg)("inlineCode",{parentName:"p"},".rodata"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," sections for each dynamic library are mapped into the process\u2019s VAS, along with the sections of the main executable."),(0,i.yg)("p",null,"To understand how these mappings are created, let\u2019s explore a simpler example.\nBelow is an illustration of how ",(0,i.yg)("inlineCode",{parentName:"p"},"libc")," is loaded (or mapped) into the VAS of an ",(0,i.yg)("inlineCode",{parentName:"p"},"ls")," process."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~$ strace ls\nopenat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3\n[...]\nmmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb313c9c000\nmmap(0x7fb313cbe000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7fb313cbe000\nmmap(0x7fb313e36000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7fb313e36000\nmmap(0x7fb313e84000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fb313e84000\n')),(0,i.yg)("p",null,"For a quick recap on ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap(addr, length, prot, flags, fd, offset)"),", the fifth argument specifies the ",(0,i.yg)("strong",{parentName:"p"},"file descriptor")," to copy data from, while the sixth is the offset within the file from where to start copying."),(0,i.yg)("p",null,"In summary, when an executable runs, the loader uses ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," to reserve memory zones for its shared libraries.\nPerformance is not affected by this since pages are populated ",(0,i.yg)("strong",{parentName:"p"},"on-demand"),", when they\u2019re accessed for the first time."),(0,i.yg)("h3",{id:"file-io-vs-mmap"},"File I/O vs ",(0,i.yg)("inlineCode",{parentName:"h3"},"mmap()")),(0,i.yg)("p",null,"When it comes to dynamic libraries, ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap")," is unmatched.\nWith a single call, it handles ",(0,i.yg)("strong",{parentName:"p"},"address mapping"),", ",(0,i.yg)("strong",{parentName:"p"},"permission setting"),", and leverages demand paging to populate pages only when accessed.\nAdditionally, ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," fully supports ",(0,i.yg)("strong",{parentName:"p"},"copy-on-write (COW)"),", allowing libraries to share the same physical frames across multiple processes, which conserves memory and reduces load time."),(0,i.yg)("p",null,"In contrast, using ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," would require loading the entire library into physical memory for each process individually, missing out on both the ",(0,i.yg)("strong",{parentName:"p"},"copy-on-write")," and ",(0,i.yg)("strong",{parentName:"p"},"demand paging")," benefits."),(0,i.yg)("p",null,"For regular files, however, the choice isn\u2019t always straightforward.\nThe main sources of overhead for ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," include managing virtual memory mappings - which can lead to ",(0,i.yg)("strong",{parentName:"p"},"TLB flushes")," - and the cost of page faults due to ",(0,i.yg)("strong",{parentName:"p"},"demand paging"),"."),(0,i.yg)("p",null,"On the plus side, ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," excels with random access patterns, efficiently reusing mapped pages.\nIt is also great for operating large amounts of data, as it enables the kernel to automatically unload and reload pages as needed when memory when under memory pressure."),(0,i.yg)("p",null,"A concrete scenario where these downsides outweigh the benefits of ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," is one-time, sequential I/O.\nIf you\u2019re simply planning to read or write a file in one go, ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write()")," are the way to go."),(0,i.yg)("h2",{id:"guide-reading-linux-directories"},"Guide: Reading Linux Directories"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Everything in Linux is a file."),"\nThis statement says that the Linux OS treats every entry in a file system (regular file, directory, block device, char device, link, UNIX socket) as a file.\nThis unified approach simplifies file handling, allowing a single interface to interact with various types of entries.\nLet's see how this works in practice:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/reading-linux-dirs/support/")," and checkout ",(0,i.yg)("inlineCode",{parentName:"p"},"dir_ops.c"),".\nThis code creates a directory ",(0,i.yg)("inlineCode",{parentName:"p"},"dir"),", if it does not exists, and attempts to open it the same way we would open a regular file.\nCompile and run the code."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../reading-linux-dirs/support$ ./dir_ops\n12:45:34 FATAL dir_ops.c:17: fopen: Is a directory\n")),(0,i.yg)("p",{parentName:"li"},"The error message is crystal clear: we cannot use ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()")," on directories.\nSo the ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," structure is unsuited for directories.\nTherefore, this handler is not generic enough for a regular Linux filesystem, and we have to use a lower-level function."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"Questions/fopen-syscall"},"Quiz - What syscall does fopen() use?"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Now that we know that ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()")," relies ",(0,i.yg)("inlineCode",{parentName:"p"},"openat()"),", let's try using ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/open.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"open()")),", which wraps ",(0,i.yg)("inlineCode",{parentName:"p"},"openat()")," but offers a simpler interface."),(0,i.yg)("p",{parentName:"li"},"Inspect, compile and run the code ",(0,i.yg)("inlineCode",{parentName:"p"},"dir_ops_syscalls.c"),"."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/...reading-linux-dirs/support$ ./dir_ops_syscalls\nDirectory file descriptor is: 3\n")),(0,i.yg)("p",{parentName:"li"},"This output proves that the ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," syscall is capable of also handling directories, so it's closer to what we want."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Note:")," that it is rather uncommon to use ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," for directories.\nMost of the time, ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/opendir.3.html"},(0,i.yg)("inlineCode",{parentName:"a"},"opendir()"))," is used instead."))),(0,i.yg)("p",null,"In conclusion, the key difference between ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," is in the type of handler they return.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"FILE")," structure from ",(0,i.yg)("inlineCode",{parentName:"p"},"fopen()")," is suited only for regular files, while the ",(0,i.yg)("strong",{parentName:"p"},"file descriptor")," returned by ",(0,i.yg)("inlineCode",{parentName:"p"},"open()")," is more flexible.\nThe differences between the two handlers are explored in the ",(0,i.yg)("a",{parentName:"p",href:"/operating-systems/IO/lab9#file-descriptors"},"file descriptors section"),"."))}m.isMDXComponent=!0},5973:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/fork-exec-e8ff2e7cb057592463ccc850bdaa0228.svg"},9234:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/piped-commands-118a36fba312c6bea5270dba74d653e2.svg"}}]);