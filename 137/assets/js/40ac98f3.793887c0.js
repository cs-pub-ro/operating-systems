"use strict";(self.webpackChunkso=self.webpackChunkso||[]).push([[1833],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>y});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),g=r,y=d["".concat(l,".").concat(g)]||d[g]||m[g]||i;return t?a.createElement(y,o(o({ref:n},c),{},{components:t})):a.createElement(y,o({ref:n},c))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8625:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(8168),r=(t(6540),t(5680));const i={},o="Lab 10 - Inter-Process Communication",s={unversionedId:"IO/lab10",id:"IO/lab10",title:"Lab 10 - Inter-Process Communication",description:"Task: Named Pipes Communication",source:"@site/docs/IO/lab10.md",sourceDirName:"IO",slug:"/IO/lab10",permalink:"/operating-systems/137/IO/lab10",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 9 - File Descriptors",permalink:"/operating-systems/137/IO/lab9"},next:{title:"Lab 11 - IO Optimizations",permalink:"/operating-systems/137/IO/lab11"}},l={},p=[{value:"Task: Named Pipes Communication",id:"task-named-pipes-communication",level:2},{value:"Task: UNIX Socket Communication",id:"task-unix-socket-communication",level:2},{value:"Task: Network Socket Communication",id:"task-network-socket-communication",level:2},{value:"Task: Receive Challenges",id:"task-receive-challenges",level:2},{value:"Unix Sockets",id:"unix-sockets",level:2},{value:"API - Hail Berkeley Sockets",id:"api---hail-berkeley-sockets",level:3},{value:"Network Sockets",id:"network-sockets",level:2},{value:"Addresses and Ports",id:"addresses-and-ports",level:3},{value:"Client-Server Model",id:"client-server-model",level:2},{value:"Client-Server UDP",id:"client-server-udp",level:3},{value:"Client-Server TCP",id:"client-server-tcp",level:3},{value:"Guide: Networking 101",id:"guide-networking-101",level:2},{value:"Local TCP and UDP Services",id:"local-tcp-and-udp-services",level:3},{value:"Conclusion",id:"conclusion",level:3}],c={toc:p},d="wrapper";function m(e){let{components:n,...i}=e;return(0,r.yg)(d,(0,a.A)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"lab-10---inter-process-communication"},"Lab 10 - Inter-Process Communication"),(0,r.yg)("h2",{id:"task-named-pipes-communication"},"Task: Named Pipes Communication"),(0,r.yg)("p",null,"Navigate to ",(0,r.yg)("inlineCode",{parentName:"p"},"chapters/io/ipc/drills/tasks/named-pipes")," and run ",(0,r.yg)("inlineCode",{parentName:"p"},"make")," to generate the ",(0,r.yg)("inlineCode",{parentName:"p"},"support")," directory.\nIn this exercise, you'll implement client-server communication between two processes using a named pipe, also called ",(0,r.yg)("strong",{parentName:"p"},"FIFO"),".\nBoth the sender and receiver are created from the same binary: run without arguments for a receiver, or with ",(0,r.yg)("inlineCode",{parentName:"p"},"-s")," for a sender."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Use the ",(0,r.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/mkfifo.3.html"},(0,r.yg)("inlineCode",{parentName:"a"},"mkfifo()")," syscall")," to create a named pipe.\nIf the FIFO already exists, use ",(0,r.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/access.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"access()"))," to check its permissions.\nIf permissions are incorrect, or if it does not exist, recreate the FIFO.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in ",(0,r.yg)("inlineCode",{parentName:"p"},"receiver_loop()")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"sender_loop()")," to enable communication.\nEnsure the FIFO is open before reading from or writing to it.\nClose the FIFO when you are done."),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Bonus"),': Run two receivers and a single sender in different terminals.\nYou may notice some "strange" behavior due to how named pipes manage data with multiple readers.\nFor more on this, see ',(0,r.yg)("a",{parentName:"p",href:"https://stackoverflow.com/a/69325284"},"this Stack Overflow thread"),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"tests/")," directory, you will need to run ",(0,r.yg)("inlineCode",{parentName:"p"},"checker.sh"),".\nThe output for a successful implementation should look like this:"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nTest for FIFO creation: PASSED\nTest for send and receive: PASSED\n")),(0,r.yg)("h2",{id:"task-unix-socket-communication"},"Task: UNIX Socket Communication"),(0,r.yg)("p",null,"Navigate to ",(0,r.yg)("inlineCode",{parentName:"p"},"chapters/io/ipc/drills/tasks/unix-socket")," and run ",(0,r.yg)("inlineCode",{parentName:"p"},"make")," to generate the ",(0,r.yg)("inlineCode",{parentName:"p"},"support")," directory.\nIn this exercise, you'll implement client-server communication between two processes using a ",(0,r.yg)("strong",{parentName:"p"},"UNIX socket"),".\nBoth the sender and receiver are created from the same binary: run without arguments for a receiver, or with ",(0,r.yg)("inlineCode",{parentName:"p"},"-s")," for a sender."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in the ",(0,r.yg)("inlineCode",{parentName:"p"},"sender_loop()"),".\nYou need to verify whether the socket exists i.e. check if the receiver has created it.\nNext, ",(0,r.yg)("strong",{parentName:"p"},"create")," your own socket and ",(0,r.yg)("strong",{parentName:"p"},"connect")," to the receiver's socket using its address (",(0,r.yg)("strong",{parentName:"p"},"Hint:")," use ",(0,r.yg)("inlineCode",{parentName:"p"},"get_sockaddr(<path>")," to obtain it).\nOnce the connection is established, you can send messages using ",(0,r.yg)("inlineCode",{parentName:"p"},"send()"),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in the ",(0,r.yg)("inlineCode",{parentName:"p"},"receiver_loop()"),".\nSimilarly, you will need to ",(0,r.yg)("strong",{parentName:"p"},"create")," a socket and ",(0,r.yg)("strong",{parentName:"p"},"bind")," it to the receiver's address (",(0,r.yg)("strong",{parentName:"p"},"Hint:")," use ",(0,r.yg)("inlineCode",{parentName:"p"},"get_sockaddr(<path>")," for this).\nInstead of connecting, you will ",(0,r.yg)("strong",{parentName:"p"},"listen")," for and ",(0,r.yg)("strong",{parentName:"p"},"accept")," incoming connections.\nWhen ",(0,r.yg)("inlineCode",{parentName:"p"},"accept()")," receives a connection request, it will return a new socket file descriptor that you can use to receive messages via ",(0,r.yg)("inlineCode",{parentName:"p"},"recv()"),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"tests/")," directory, you will need to run ",(0,r.yg)("inlineCode",{parentName:"p"},"checker.sh"),".\nThe output for a successful implementation should look like this:"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nTest for socket creation: PASSED\nTest for send and receive: PASSED\n")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#unix-sockets"},"this reading material"),"."),(0,r.yg)("h2",{id:"task-network-socket-communication"},"Task: Network Socket Communication"),(0,r.yg)("p",null,"Navigate to ",(0,r.yg)("inlineCode",{parentName:"p"},"chapters/io/ipc/drills/tasks/network-socket")," and run ",(0,r.yg)("inlineCode",{parentName:"p"},"make")," to generate the ",(0,r.yg)("inlineCode",{parentName:"p"},"support")," directory.\nIn this exercise, you'll implement client-server communication between two processes using a ",(0,r.yg)("strong",{parentName:"p"},"network socket"),".\nBoth the sender and receiver are created from the same binary: run without arguments for a receiver, or with ",(0,r.yg)("inlineCode",{parentName:"p"},"-s")," for a sender."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in the ",(0,r.yg)("inlineCode",{parentName:"p"},"sender_loop()")," from ",(0,r.yg)("inlineCode",{parentName:"p"},"tcp_socket.c"),".\nYou need to verify whether the socket exists i.e. check if the receiver has created it.\nNext, ",(0,r.yg)("strong",{parentName:"p"},"create")," your own socket and ",(0,r.yg)("strong",{parentName:"p"},"connect")," to the receiver's socket using its address (",(0,r.yg)("strong",{parentName:"p"},"Hint:")," use ",(0,r.yg)("inlineCode",{parentName:"p"},"get_sockaddr(<IP>, <PORT>)")," to obtain it).\nOnce the connection is established, you can send messages using ",(0,r.yg)("inlineCode",{parentName:"p"},"send()"),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in the ",(0,r.yg)("inlineCode",{parentName:"p"},"receiver_loop()")," from ",(0,r.yg)("inlineCode",{parentName:"p"},"tcp_socket.c"),".\nSimilarly, you will need to ",(0,r.yg)("strong",{parentName:"p"},"create")," a socket and ",(0,r.yg)("strong",{parentName:"p"},"bind")," it to the receiver's address (",(0,r.yg)("strong",{parentName:"p"},"Hint:")," use ",(0,r.yg)("inlineCode",{parentName:"p"},"get_sockaddr(<IP>, <PORT>)")," for this).\nInstead of connecting, you will ",(0,r.yg)("strong",{parentName:"p"},"listen")," for and ",(0,r.yg)("strong",{parentName:"p"},"accept")," incoming connections.\nWhen ",(0,r.yg)("inlineCode",{parentName:"p"},"accept()")," receives a connection request, it will return a new socket file descriptor that you can use to receive messages via ",(0,r.yg)("inlineCode",{parentName:"p"},"recv()"),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Now we\u2019ll implement the same functionality using datagrams (",(0,r.yg)("inlineCode",{parentName:"p"},"SOCK_DGRAM"),").\nOpen ",(0,r.yg)("inlineCode",{parentName:"p"},"udp_socket.c")," and complete the TODOs for ",(0,r.yg)("inlineCode",{parentName:"p"},"sender_loop()")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"receiver_loop()")," functions.\nThe workflow is similar, but ",(0,r.yg)("inlineCode",{parentName:"p"},"listen()"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"accept()"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"connect()")," are not required for datagram sockets.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"tests/")," directory, you will need to run ",(0,r.yg)("inlineCode",{parentName:"p"},"checker.sh"),".\nThe output for a successful implementation should look like this:"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"./checker.sh\nTest for TCP state: PASSED\n[Sender]: OS{Hello OS enjoyers!!}\n[Sender]:\nTest for TCP receiving the message: PASSED\n\nTest for UDP state: PASSED\n[Sender]: OS{Are you enjoying this lab?!}\n[Sender]:\nTest for UDP receiving the message: PASSED\n")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#network-sockets"},"this reading material"),"."),(0,r.yg)("h2",{id:"task-receive-challenges"},"Task: Receive Challenges"),(0,r.yg)("p",null,"Navigate to ",(0,r.yg)("inlineCode",{parentName:"p"},"chapters/io/ipc/drills/tasks/receive-challenges")," and run ",(0,r.yg)("inlineCode",{parentName:"p"},"make")," to generate the ",(0,r.yg)("inlineCode",{parentName:"p"},"support")," directory.\nIn this task, we will review all the IPC methods we have explored, including ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab9#pipes"},"anonymous pipes"),", ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab9#pipes"},"named pipes (FIFOs)"),", ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#unix-sockets"},"UNIX sockets"),", and ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#network-sockets"},"network sockets"),".\nEach challenge involves building a communication channel using the specified IPC method."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in ",(0,r.yg)("inlineCode",{parentName:"p"},"support/receive_pipe.c"),", then compile and run the executable.\nIf the challenge is completed successfully, you should see the message ",(0,r.yg)("inlineCode",{parentName:"p"},"Flag is ..."),".")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in ",(0,r.yg)("inlineCode",{parentName:"p"},"support/receive_fifo.c"),", then compile and run the executable.\nYou will need to run the ",(0,r.yg)("inlineCode",{parentName:"p"},"send_fifo")," executable while your process is running to reveal the flag.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in ",(0,r.yg)("inlineCode",{parentName:"p"},"support/receive_unix_socket.c"),", then compile and run the executable.\nYou will need to run the ",(0,r.yg)("inlineCode",{parentName:"p"},"send_unix_socket")," executable while your process is running to reveal the flag.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Complete the TODOs in ",(0,r.yg)("inlineCode",{parentName:"p"},"support/receive_net_dgram_socket.c"),", then compile and run the executable.\nYou will need to run the ",(0,r.yg)("inlineCode",{parentName:"p"},"send_net_dgram_socket")," executable while your process is running to reveal the flag."))),(0,r.yg)("h2",{id:"unix-sockets"},"Unix Sockets"),(0,r.yg)("p",null,"Unix sockets are a inter-process communication (IPC) method that addresses some limitations of ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab9#pipes"},"pipes"),".\nTheir key characteristics are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Bidirectional communication"),": Allowing both ",(0,r.yg)("inlineCode",{parentName:"li"},"send")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"receive")," operations through the same file descriptor."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Data transmission modes"),": Supporting both ",(0,r.yg)("inlineCode",{parentName:"li"},"stream")," (continuous data flow) and ",(0,r.yg)("inlineCode",{parentName:"li"},"datagram")," (message-based) models."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Connection-based"),": Maintaining a connection between processes, so the sender's identity is always known.")),(0,r.yg)("h3",{id:"api---hail-berkeley-sockets"},"API - Hail Berkeley Sockets"),(0,r.yg)("p",null,"Unix sockets are managed through the ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Berkeley_sockets"},"Berkeley Sockets API"),", which is widely supported across various operating systems and programming languages.\nThis API is not limited to ",(0,r.yg)("strong",{parentName:"p"},"Unix sockets"),"; it also enables communication with processes on remote systems using ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#network-sockets"},(0,r.yg)("strong",{parentName:"a"},"network sockets"))),(0,r.yg)("p",null,"The socket interface works similarly to the file interface, offering system calls for creating, reading, and writing data.\nIt also includes additional calls for setting up addresses, handling connections, and connecting to remote hosts:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/socket.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"socket(domain, type, protocol)"))),": Creates a new socket and returns a file descriptor for further operations.",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"domain")," argument determines whether the socket is intended for ",(0,r.yg)("strong",{parentName:"li"},"local connections")," (Unix socket) or ",(0,r.yg)("strong",{parentName:"li"},"remote connections")," (network socket)."),(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"type")," argument specifies the communication mode, either ",(0,r.yg)("inlineCode",{parentName:"li"},"SOCK_STREAM")," for stream-oriented communication or ",(0,r.yg)("inlineCode",{parentName:"li"},"SOCK_DGRAM")," for datagram-oriented communication."),(0,r.yg)("li",{parentName:"ul"},"The ",(0,r.yg)("inlineCode",{parentName:"li"},"protocol")," argument indicates the protocol to use, which is often set to ",(0,r.yg)("inlineCode",{parentName:"li"},"0"),", as there is typically only one protocol available for each socket type within a specific protocol family."))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/bind.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"bind()"))),": Associates an address and port with the socket.\nFor Unix sockets, ",(0,r.yg)("inlineCode",{parentName:"li"},"bind()")," also creates a file on disk as the socket identifier."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/listen.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"listen()"))),": Sets the socket to passive mode, preparing it to accept incoming connections."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/accept.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"accept()"))),": Accepts a pending connection and returns a new socket for it, blocking if no connections are pending."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/connect.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"connect()"))),": Initiates a connection to a remote socket."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/send.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"send()")," / ",(0,r.yg)("inlineCode",{parentName:"a"},"sendto()"))),": Sends data over the socket, similar to ",(0,r.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man2/write.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"write()")),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"https://man7.org/linux/man-pages/man2/recv.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"recv()")," / ",(0,r.yg)("inlineCode",{parentName:"a"},"recvfrom()"))),": Receives data from the socket, akin to ",(0,r.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man2/read.2.html"},(0,r.yg)("inlineCode",{parentName:"a"},"read()")),".")),(0,r.yg)("p",null,"Before utilizing the API, it's essential to understand that for two processes to communicate, they need a way to identify the socket.\nThis identification method is similar to that used with named pipes, relying on a file identifier stored on disk.\nIf the file identifier does not already exist, it will be created by the ",(0,r.yg)("inlineCode",{parentName:"p"},"bind()")," function.\nBelow is an example of how to implement this in code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'char path[] = "my-socket";\nstruct sockaddr_un addr;  // Structure to hold the address for the UNIX socket.\n\nmemset(&addr, 0, sizeof(addr));                   // Clear the address structure.\naddr.sun_family = AF_UNIX;                        // Set the address family.\nsnprintf(addr.sun_path, sizeof(addr.sun_path), "%s", path); // Set the path.\n\nsockfd = socket(PF_UNIX, SOCK_STREAM, 0);        // Create the socket.\nif (sockfd < 0) {...} // handle error\n\nrc = bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)); // Bind the socket.\nif (rc < 0) {...} // handle error\n')),(0,r.yg)("p",null,"You can practice working with UNIX sockets by completing the ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#task-unix-socket-communication"},"UNIX Sockets Communication task"),"."),(0,r.yg)("h2",{id:"network-sockets"},"Network Sockets"),(0,r.yg)("p",null,"Network sockets are an inter-process communication (IPC) method that enables communication between processes on different hosts.\nThey are managed through the ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Berkeley_sockets"},"Berkeley Sockets API"),", which is widely supported across various operating systems and programming languages.\nThe API is further explored in the ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#unix-sockets"},"Unix sockets section"),".\nThis section focuses on identifying peer processes and establishing connections between them."),(0,r.yg)("h3",{id:"addresses-and-ports"},"Addresses and Ports"),(0,r.yg)("p",null,"The most crucial aspect of remote I/O is identifying the correct endpoint for communication.\nWhether you are connecting to a website or a Minecraft server, you need a reliable way to specify the application you want to interact with.\nThis is where IP addresses and ports come into play."),(0,r.yg)("p",null,"An ",(0,r.yg)("strong",{parentName:"p"},"IP address")," is a unique numerical label assigned to each device on a network.\nIt functions like a mailing address, ensuring that data packets reach the correct destination.\nFor example, if you want to access a website, your browser connects to the server's IP address, so that the server knows where to send the requested data.\nBut what if there is more than one server running at that IP address?"),(0,r.yg)("p",null,"This is the reason we need ports.\nA port is simply a ",(0,r.yg)("strong",{parentName:"p"},"number")," that ",(0,r.yg)("strong",{parentName:"p"},"uniquely identifies a connection")," on a device.\nWhen an application performs remote I/O, it requests a port from the operating system and begins listening for incoming data on that port.\nHowever, how do clients know which port the application is using?\nTypically, this information is transmitted by user or established by convention.\nFor instance, popular applications have predefined ports: ",(0,r.yg)("inlineCode",{parentName:"p"},"SSH")," uses port ",(0,r.yg)("inlineCode",{parentName:"p"},"22"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"HTTP")," operates on port ",(0,r.yg)("inlineCode",{parentName:"p"},"80"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"HTTPS")," defaults to port ",(0,r.yg)("inlineCode",{parentName:"p"},"443"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note"),": In most cases, you don\u2019t interact with IP addresses and ports directly.\nFor example, when you access ",(0,r.yg)("inlineCode",{parentName:"p"},"https://cs-pub-ro.github.io/operating-systems/"),", you don\u2019t see any numbers.\nBehind the scenes, the ",(0,r.yg)("a",{parentName:"p",href:"https://www.ibm.com/topics/dns"},"DNS")," translates the domain name cs-pub-ro.github.io to its corresponding IP address, while the HTTPS protocol automatically uses port 443 by default."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note:")," You can use network sockets for communication between local processes.\nEach host provides a ",(0,r.yg)("inlineCode",{parentName:"p"},"localhost")," address (commonly ",(0,r.yg)("inlineCode",{parentName:"p"},"127.0.0.1"),") or a loopback address that can be used for this purpose."),(0,r.yg)("p",null,"Let's take a coding example to see how addresses and ports are used to identify a process over the network:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'##define PORT 12345\nstruct sockaddr_in addr;  // Structure to hold the address for the network socket.\n\nmemset(&addr, 0, sizeof(addr));                         // Clear the address structure.\naddr.sin_family = AF_INET;                              // Set the address family to IPv4.\nserver_addr.sin_addr.s_addr = inet_addr("127.0.0.1");   // Set the server\'s IP address (localhost).\naddr.sin_port = htons(PORT);                            // Set the port number.\n\nint sockfd = socket(AF_INET, SOCK_STREAM, 0);           // Create the socket.\nif (sockfd < 0) {...} // handle error\n\nint rc = bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)); // Bind the socket.\nif (rc < 0) {...} // handle error\n')),(0,r.yg)("p",null,"You can practice working with network sockets by completing the ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#task-network-socket-communication"},"Network Sockets Communication task"),"."),(0,r.yg)("h2",{id:"client-server-model"},"Client-Server Model"),(0,r.yg)("p",null,"In our previous IPC examples, we used the terms ",(0,r.yg)("strong",{parentName:"p"},"sender")," and ",(0,r.yg)("strong",{parentName:"p"},"receiver"),".\nIn practice, these are commonly referred to as the ",(0,r.yg)("strong",{parentName:"p"},"client")," (sender) and ",(0,r.yg)("strong",{parentName:"p"},"server")," (receiver).\nWhile the socket API provides the necessary tools for communication, it doesn\u2019t define an actual communication protocol.\nThis is where an ",(0,r.yg)("strong",{parentName:"p"},"application protocol")," comes in (distinct from transport protocols like ",(0,r.yg)("inlineCode",{parentName:"p"},"UDP")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"TCP"),").\nAn application protocol defines the rules and structure for how the communication should take place.\nFor example, in the ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#task-network-socket-communication"},"Network Sockets Communication task"),", the ",(0,r.yg)("strong",{parentName:"p"},"server")," stops upon receiving the ",(0,r.yg)("inlineCode",{parentName:"p"},"exit")," string from the ",(0,r.yg)("strong",{parentName:"p"},"client"),"."),(0,r.yg)("p",null,"It\u2019s important to keep in mind how the networking protocol impacts the design of each component:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"With ",(0,r.yg)("strong",{parentName:"li"},"UDP")," (",(0,r.yg)("inlineCode",{parentName:"li"},"SOCK_DGRAM"),"), there is no active connection.\nThe server simply waits for incoming messages and handles them as they arrive.\nUnlike TCP, UDP ",(0,r.yg)("strong",{parentName:"li"},"does not guarantee message delivery")," and messages may be lost during transmission.\nIt is up to the ",(0,r.yg)("strong",{parentName:"li"},"application")," to manage these concerns.\nFor example, a client might resend a request if it does not receive a response within 3 seconds."),(0,r.yg)("li",{parentName:"ul"},"With ",(0,r.yg)("strong",{parentName:"li"},"TCP")," (",(0,r.yg)("inlineCode",{parentName:"li"},"SOCK_STREAM"),"), a ",(0,r.yg)("strong",{parentName:"li"},"connection is created and maintained")," between the client and server.\nTCP guarantees that messages arrive in the correct order and will automatically resend data if network issues occur.")),(0,r.yg)("p",null,"For a dive into how TCP and UDP are used in real-world scenarios checkout the ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab10#guide-networking-101"},"Networking 101 guide"),"."),(0,r.yg)("h3",{id:"client-server-udp"},"Client-Server UDP"),(0,r.yg)("p",null,"Setting up a UDP client-server communication is straightforward and lightweight.\nA typical workflow for a UDP ",(0,r.yg)("strong",{parentName:"p"},"server")," involves:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"socket(AF_INET, SOCK_DGRAM, 0)")," - creating a UDP network socket."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"bind(sockfd, &addr, sizeof(addr))")," - binding the socket to an address with an ",(0,r.yg)("inlineCode",{parentName:"li"},"IP")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"port")," for network sockets."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"recvfrom(sockfd, buffer, BUFSIZ, 0, &caddr, &caddrlen);")," - waiting for a message from the client.\n",(0,r.yg)("strong",{parentName:"li"},"Note:")," The last two parameters are used to retrieve the client's address information.")),(0,r.yg)("p",null,"The server requires ",(0,r.yg)("inlineCode",{parentName:"p"},"bind()")," to assign a specific IP and port for listening, so clients know exactly where to connect.\nFor network clients, ",(0,r.yg)("inlineCode",{parentName:"p"},"bind()")," is optional;\nif the IP and port are not specified, they are automatically assigned."),(0,r.yg)("p",null,"The typical workflow for a UDP ",(0,r.yg)("strong",{parentName:"p"},"client")," comprises of the following steps:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"socket(AF_INET, SOCK_DGRAM, 0)")," - creating a UDP network socket"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"sendto(fd, buffer, BUFSIZ, 0, (struct sockaddr *)&svaddr, svaddrlen);")," - sending a message to the server.")),(0,r.yg)("h3",{id:"client-server-tcp"},"Client-Server TCP"),(0,r.yg)("p",null,"Setting up a TCP client-server communication involves a few more steps than UDP but remains relatively straightforward.\nA typical workflow for a TCP ",(0,r.yg)("strong",{parentName:"p"},"server")," is as follows:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"socket(AF_INET, SOCK_STREAM, 0)")," - creating a TCP network socket."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"bind(sockfd, &addr, sizeof(addr))")," - binding the socket to an address with an ",(0,r.yg)("inlineCode",{parentName:"li"},"IP")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"port")," for network sockets."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"listen(sockfd, backlog)")," - marking the socket as passive, ready to accept incoming connections.\nThe ",(0,r.yg)("inlineCode",{parentName:"li"},"backlog")," defines the maximum number of pending connections.\nThis is usually set to the maximum number of clients you are expecting."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"accept(sockfd, &client_addr, &client_len)")," - accepting a new connection from a client and returning a new socket descriptor for communication.\nKeep in mind that the server will block until a connection arrives."),(0,r.yg)("li",{parentName:"ul"},"Once the connection is accepted, you can communicate with the client using ",(0,r.yg)("inlineCode",{parentName:"li"},"send(sockfd, buffer, BUFSIZ, 0)")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"recv(sockfd, buffer, BUFSIZ, 0)"),".")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note:")," The server requires ",(0,r.yg)("inlineCode",{parentName:"p"},"bind()")," to specify a particular IP and port for listening.\nThis way, clients can connect to the correct address.\nAfter binding, the server uses ",(0,r.yg)("inlineCode",{parentName:"p"},"listen()")," to prepare for incoming connections and ",(0,r.yg)("inlineCode",{parentName:"p"},"accept()")," to handle them."),(0,r.yg)("p",null,"On the ",(0,r.yg)("strong",{parentName:"p"},"client")," side, the typical workflow is:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"socket(AF_INET, SOCK_STREAM, 0)")," - creating a TCP network socket (also works for Unix sockets)."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"connect(sockfd, (struct sockaddr *)&svaddr, svaddrlen)")," - connecting to the server using the server's ",(0,r.yg)("inlineCode",{parentName:"li"},"IP")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"port"),".\nUnlike UDP, ",(0,r.yg)("inlineCode",{parentName:"li"},"connect()")," is required to establish a connection to the server."),(0,r.yg)("li",{parentName:"ul"},"Once connected, you can communicate with the server using ",(0,r.yg)("inlineCode",{parentName:"li"},"send(sockfd, buffer, BUFSIZ, 0)")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"recv(sockfd, buffer, BUFSIZ, 0)"),".")),(0,r.yg)("p",null,"Test your understanding by building a ",(0,r.yg)("a",{parentName:"p",href:"/operating-systems/137/IO/lab11#task-ordered-client-server-communication"},"sequential client-server communication"),"."),(0,r.yg)("h2",{id:"guide-networking-101"},"Guide: Networking 101"),(0,r.yg)("p",null,"In this section, we will ",(0,r.yg)("strong",{parentName:"p"},"briefly")," explore how networking works in general, from the perspective of the application.\nUnderstanding the details of it, however, is beyond the scope of this course."),(0,r.yg)("p",null,"The main ",(0,r.yg)("strong",{parentName:"p"},"protocols")," used by applications are ",(0,r.yg)("strong",{parentName:"p"},"User Datagram Protocol (UDP)")," and ",(0,r.yg)("strong",{parentName:"p"},"Transmission Control Protocol (TCP)"),"."),(0,r.yg)("p",null,"UDP is the simpler of the two protocols.\nIt simply sends data to a receiver identified by an IP and port.\nIt does not care whether the receiver has got all the data, whether it was corrupted or dropped altogether by some router along the way."),(0,r.yg)("p",null,"At first glance, UDP might seem useless due to its lack of reliability checks.\nHowever, this simplicity makes UDP ",(0,r.yg)("strong",{parentName:"p"},"fast"),".\nAs a result, it is often used for ",(0,r.yg)("strong",{parentName:"p"},"real-time services"),", such as video streaming or voice calls, where minor data losses (like dropped frames) are less problematic because they are quickly replaced by new data, masking any errors."),(0,r.yg)("p",null,"On the other hand, TCP offers ",(0,r.yg)("strong",{parentName:"p"},"reliability"),".\nIt ensures that data is received correctly by performing error checks and retransmitting any lost or corrupted packets.\nThis makes TCP ideal for applications that require guaranteed delivery, such as ",(0,r.yg)("strong",{parentName:"p"},"web browsing")," or ",(0,r.yg)("strong",{parentName:"p"},"file transfers"),", where accuracy and completeness are critical."),(0,r.yg)("h3",{id:"local-tcp-and-udp-services"},"Local TCP and UDP Services"),(0,r.yg)("p",null,"To get a full list of all network-handling processes in your system together with the protocols they're using, we can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"netstat")," with the ",(0,r.yg)("inlineCode",{parentName:"p"},"-tuanp")," arguments.\n",(0,r.yg)("inlineCode",{parentName:"p"},"-tuanp")," is short for ",(0,r.yg)("inlineCode",{parentName:"p"},"-t -u -a -n -p"),", which stand for:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-t"),": list processes using the TCP protocol"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-u"),": list processes using the UDP protocol"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-a"),": list both servers and clients"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-n"),": list IPs in numeric format"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"-p"),": show the PID and name of each program")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~$ sudo netstat -tunp\nActive Internet connections (w/o servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1057/sshd: /usr/sbi\ntcp        0      0 127.0.0.1:6463          0.0.0.0:*               LISTEN      3261/Discord --type\ntcp        0      0 192.168.100.2:51738     162.159.128.235:443     ESTABLISHED 3110/Discord --type\ntcp        0      0 192.168.100.2:43694     162.159.129.235:443     ESTABLISHED 3110/Discord --type\ntcp        0      0 192.168.100.2:56230     54.230.159.113:443      ESTABLISHED 9154/firefox\ntcp        0      0 192.168.100.2:38096     34.107.141.31:443       ESTABLISHED 9154/firefox\ntcp        0      0 192.168.100.2:42462     34.117.237.239:443      ESTABLISHED 9154/firefox\ntcp        0      0 192.168.100.2:41128     162.159.135.234:443     ESTABLISHED 3110/Discord --type\ntcp6       0      0 :::80                   :::*                    LISTEN      1114/apache2\ntcp6       0      0 :::22                   :::*                    LISTEN      1057/sshd: /usr/sbi\ntcp6       0      0 2a02:2f0a:c10f:97:55754 2a02:2f0c:dff0:b::1:443 ESTABLISHED 9154/firefox\ntcp6       0      0 2a02:2f0a:c10f:97:55750 2a02:2f0c:dff0:b::1:443 ESTABLISHED 9154/firefox\nudp        0      0 0.0.0.0:56585           0.0.0.0:*                           3261/Discord --type\nudp        0      0 0.0.0.0:42629           0.0.0.0:*                           3261/Discord --type\nudp6       0      0 :::52070                :::*                                9154/firefox\nudp6       0      0 :::38542                :::*                                9154/firefox\n")),(0,r.yg)("p",null,"Your output will likely differ from the example above.\nLet\u2019s focus on the fourth column, which displays the local address and port in use by each process.\nThe first 1024 ports are reserved for well-known applications, ensuring consistency across networks.\nFor example, ",(0,r.yg)("inlineCode",{parentName:"p"},"SSH")," uses port ",(0,r.yg)("inlineCode",{parentName:"p"},"22")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Apache2")," uses port ",(0,r.yg)("inlineCode",{parentName:"p"},"80")," for both IPv4 and IPv6 addresses (look for rows starting with ",(0,r.yg)("inlineCode",{parentName:"p"},"tcp")," for IPv4 and ",(0,r.yg)("inlineCode",{parentName:"p"},"tcp6")," for IPv6)."),(0,r.yg)("p",null,"Some user programs, like Firefox, establish multiple connections, often using both IPv4 and IPv6, with each connection assigned a unique port.\nDiscord is another example, using TCP to handle text messages, images, videos, and other static content, while relying on UDP for real-time voice and video data during calls."),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"Questions/firefox-tcp-udp"},"Quiz: Why does Firefox uses both TCP and UDP?")),(0,r.yg)("h3",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"The difference between TCP and UDP can be summarised as follows:"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"TCP vs UDP",src:t(7212).A,width:"460",height:"386"})))}m.isMDXComponent=!0},7212:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/tcp-udp-simplified-7bb728409d8a83b05d5d574df21d9ec4.png"}}]);