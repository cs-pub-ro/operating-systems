"use strict";(self.webpackChunkso=self.webpackChunkso||[]).push([[6651],{5680:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>u});var r=a(6540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function i(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var s=r.createContext({}),m=function(e){var n=r.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},c=function(e){var n=m(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=m(a),d=t,u=p["".concat(s,".").concat(d)]||p[d]||y[d]||o;return a?r.createElement(u,l(l({ref:n},c),{},{components:a})):r.createElement(u,l({ref:n},c))}));function u(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=a.length,l=new Array(o);l[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[p]="string"==typeof e?e:t,l[1]=i;for(var m=2;m<o;m++)l[m]=a[m];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},133:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>y,frontMatter:()=>o,metadata:()=>i,toc:()=>m});var r=a(8168),t=(a(6540),a(5680));const o={},l="Memory Leaks",i={unversionedId:"Data/Lab 4 - Investigate Memory/Guides/Memory Leak/README",id:"Data/Lab 4 - Investigate Memory/Guides/Memory Leak/README",title:"Memory Leaks",description:"A memory leak occurs when we lose reference to a memory area.",source:"@site/docs/Data/Lab 4 - Investigate Memory/Guides/Memory Leak/README.md",sourceDirName:"Data/Lab 4 - Investigate Memory/Guides/Memory Leak",slug:"/Data/Lab 4 - Investigate Memory/Guides/Memory Leak/",permalink:"/operating-systems/77/Data/Lab 4 - Investigate Memory/Guides/Memory Leak/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Memory Actions (and Leaks) in Existing Programs",permalink:"/operating-systems/77/Data/Lab 4 - Investigate Memory/Guides/Memory Actions/"},next:{title:"Lab 5 - Memory Security",permalink:"/operating-systems/77/Data/Lab 5 - Memory Security/"}},s={},m=[{value:"Practice",id:"practice",level:3}],c={toc:m},p="wrapper";function y(e){let{components:n,...a}=e;return(0,t.yg)(p,(0,r.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"memory-leaks"},"Memory Leaks"),(0,t.yg)("p",null,"A memory leak occurs when we lose reference to a memory area.\nThat is, a pointer used to point to a memory area.\nAnd then it's pointing to a new memory area and the old memory area is lost."),(0,t.yg)("p",null,"Enter the ",(0,t.yg)("inlineCode",{parentName:"p"},"support/memory-leak/")," folder.\nIt stores two files showing memory leaks:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"one in C++: ",(0,t.yg)("inlineCode",{parentName:"li"},"memory_leak.cpp")),(0,t.yg)("li",{parentName:"ul"},"one in C: ",(0,t.yg)("inlineCode",{parentName:"li"},"memory_leak_malloc"))),(0,t.yg)("p",null,"Let's build and run the two executables:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../lab/support/memory-leak$ make\ng++    -c -o memory_leak.o memory_leak.cpp\ncc   memory_leak.o  -lstdc++ -o memory_leak\ncc    -c -o memory_leak_malloc.o memory_leak_malloc.c\ncc   memory_leak_malloc.o  -lstdc++ -o memory_leak_malloc\n")),(0,t.yg)("p",null,"Running them yields similar output:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../lab/support/memory-leak$ ./memory_leak\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\nstudent@os:~/.../lab/support/memory-leak$ ./memory_leak_malloc\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n")),(0,t.yg)("p",null,"We investigate the memory leaks of the two programs by using ",(0,t.yg)("a",{parentName:"p",href:"https://valgrind.org/"},"Valgrind"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../lab/support/memory-leak$ valgrind ./memory_leak\n==22362== Memcheck, a memory error detector\n==22362== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==22362== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==22362== Command: ./memory_leak\n==22362==\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n==22362==\n==22362== HEAP SUMMARY:\n==22362==     in use at exit: 72 bytes in 1 blocks\n==22362==   total heap usage: 4 allocs, 3 frees, 73,872 bytes allocated\n==22362==\n==22362== LEAK SUMMARY:\n==22362==    definitely lost: 72 bytes in 1 blocks\n==22362==    indirectly lost: 0 bytes in 0 blocks\n==22362==      possibly lost: 0 bytes in 0 blocks\n==22362==    still reachable: 0 bytes in 0 blocks\n==22362==         suppressed: 0 bytes in 0 blocks\n==22362== Rerun with --leak-check=full to see details of leaked memory\n==22362==\n==22362== For counts of detected and suppressed errors, rerun with: -v\n==22362== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\nstudent@os:~/.../lab/support/memory-leak$ valgrind ./memory_leak_malloc\n==22369== Memcheck, a memory error detector\n==22369== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==22369== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==22369== Command: ./memory_leak_malloc\n==22369==\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n==22369==\n==22369== HEAP SUMMARY:\n==22369==     in use at exit: 148 bytes in 1 blocks\n==22369==   total heap usage: 3 allocs, 2 frees, 1,320 bytes allocated\n==22369==\n==22369== LEAK SUMMARY:\n==22369==    definitely lost: 148 bytes in 1 blocks\n==22369==    indirectly lost: 0 bytes in 0 blocks\n==22369==      possibly lost: 0 bytes in 0 blocks\n==22369==    still reachable: 0 bytes in 0 blocks\n==22369==         suppressed: 0 bytes in 0 blocks\n==22369== Rerun with --leak-check=full to see details of leaked memory\n==22369==\n==22369== For counts of detected and suppressed errors, rerun with: -v\n==22369== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n")),(0,t.yg)("p",null,"As we are doing allocations that are not freed, this results in memory leaks."),(0,t.yg)("p",null,"For ",(0,t.yg)("inlineCode",{parentName:"p"},"malloc()"),"-based programs, we can use ",(0,t.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/mtrace.3.html"},(0,t.yg)("inlineCode",{parentName:"a"},"mtrace()")," feature")," and ",(0,t.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/mtrace.1.html"},(0,t.yg)("inlineCode",{parentName:"a"},"mtrace")," command")," to verify proper allocations with ",(0,t.yg)("inlineCode",{parentName:"p"},"malloc()")," and deallocations with ",(0,t.yg)("inlineCode",{parentName:"p"},"free()"),".\nWe call ",(0,t.yg)("inlineCode",{parentName:"p"},"mtrace()")," in the program (in ",(0,t.yg)("inlineCode",{parentName:"p"},"memory_leak_malloc.c"),") to enable ",(0,t.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"free()")," checking."),(0,t.yg)("p",null,"To use ",(0,t.yg)("inlineCode",{parentName:"p"},"mtrace()")," we define the ",(0,t.yg)("inlineCode",{parentName:"p"},"MALLOC_TRACE")," environment variable.\nWe probably also require to preload the libc malloc debugging library, so we use ",(0,t.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," for that.\nNote that the file path used for ",(0,t.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," may need to be updated, depending on your distribution:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../lab/support/memory-leak$ LD_PRELOAD=/lib/x86_64-linux-gnu/libc_malloc_debug.so.0 MALLOC_TRACE=mem.trace ./memory_leak_malloc\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n")),(0,t.yg)("p",null,"Subsequently, we use the ",(0,t.yg)("inlineCode",{parentName:"p"},"mtrace")," tool to show information about the leaked data:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../lab/support/memory-leak$ mtrace ./memory_leak_malloc mem.trace\n\nMemory not freed:\n-----------------\n           Address     Size     Caller\n0x000056506d8be6a0     0x94  at 0x56506c3777ec\n")),(0,t.yg)("p",null,"The size (",(0,t.yg)("inlineCode",{parentName:"p"},"0x94"),") is the same value shown by Valgrind (",(0,t.yg)("inlineCode",{parentName:"p"},"148"),")."),(0,t.yg)("p",null,(0,t.yg)("inlineCode",{parentName:"p"},"mtrace")," provides an outcome similar to Valgrind.\nValgrind is however more powerful: it works on different types of memory (not only those allocated with ",(0,t.yg)("inlineCode",{parentName:"p"},"malloc()"),") and it doesn't require access to the source code (and the compiler phase)."),(0,t.yg)("h3",{id:"practice"},"Practice"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},"Print the size of the ",(0,t.yg)("inlineCode",{parentName:"p"},"Student")," class and the ",(0,t.yg)("inlineCode",{parentName:"p"},"struct student")," structure to see if it equates to the leak shown by Valgrind.")),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("p",{parentName:"li"},"Solve the memory leaks in both programs.\nValidate with Valgrind."))))}y.isMDXComponent=!0}}]);