"use strict";(self.webpackChunkso=self.webpackChunkso||[]).push([[895],{5680:(e,a,t)=>{t.d(a,{xA:()=>m,yg:()=>d});var n=t(6540);function l(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){l(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=n.createContext({}),p=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},m=function(e){var a=p(e.components);return n.createElement(o.Provider,{value:a},e.children)},c="mdxType",y={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},g=n.forwardRef((function(e,a){var t=e.components,l=e.mdxType,s=e.originalType,o=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(t),g=l,d=c["".concat(o,".").concat(g)]||c[g]||y[g]||s;return t?n.createElement(d,r(r({ref:a},m),{},{components:t})):n.createElement(d,r({ref:a},m))}));function d(e,a){var t=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var s=t.length,r=new Array(s);r[0]=g;var i={};for(var o in a)hasOwnProperty.call(a,o)&&(i[o]=a[o]);i.originalType=e,i[c]="string"==typeof e?e:l,r[1]=i;for(var p=2;p<s;p++)r[p]=t[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},278:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>y,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var n=t(8168),l=(t(6540),t(5680));const s={},r="Lab 1 - Operating System Perspective",i={unversionedId:"Software Stack/lab1",id:"Software Stack/lab1",title:"Lab 1 - Operating System Perspective",description:"Task: System Calls",source:"@site/docs/Software Stack/lab1.md",sourceDirName:"Software Stack",slug:"/Software Stack/lab1",permalink:"/operating-systems/136/Software Stack/lab1",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"strcpy() System Call",permalink:"/operating-systems/136/Software Stack/Questions/strcpy-syscall"},next:{title:"Lab 2 - Library Perspective",permalink:"/operating-systems/136/Software Stack/lab2"}},o={},p=[{value:"Task: System Calls",id:"task-system-calls",level:2},{value:"Task: System Call Wrappers",id:"task-system-call-wrappers",level:2},{value:"Task: Library Calls vs System Calls",id:"task-library-calls-vs-system-calls",level:2},{value:"Modern Software Stacks",id:"modern-software-stacks",level:2},{value:"Analyzing the Software Stack",id:"analyzing-the-software-stack",level:2},{value:"System Calls Explained",id:"system-calls-explained",level:3},{value:"Basic System Calls",id:"basic-system-calls",level:3},{value:"System Call Wrappers",id:"system-call-wrappers",level:2},{value:"Library calls vs System Calls",id:"library-calls-vs-system-calls",level:2}],m={toc:p},c="wrapper";function y(e){let{components:a,...s}=e;return(0,l.yg)(c,(0,n.A)({},m,s,{components:a,mdxType:"MDXLayout"}),(0,l.yg)("h1",{id:"lab-1---operating-system-perspective"},"Lab 1 - Operating System Perspective"),(0,l.yg)("h2",{id:"task-system-calls"},"Task: System Calls"),(0,l.yg)("p",null,"Enter the ",(0,l.yg)("inlineCode",{parentName:"p"},"chapters/software-stack/system-calls/drills/tasks/basic-syscall/")," folder.\nRun ",(0,l.yg)("inlineCode",{parentName:"p"},"make")," and then enter ",(0,l.yg)("inlineCode",{parentName:"p"},"chapters/software-stack/system-calls/drills/tasks/basic-syscall/support/")," folder and go through the practice items below."),(0,l.yg)("p",null,"For debugging, use ",(0,l.yg)("inlineCode",{parentName:"p"},"strace")," to trace the system calls from your program and make sure the arguments are set right."),(0,l.yg)("ol",null,(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Update the ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.asm")," and / or ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.s")," files to print both ",(0,l.yg)("inlineCode",{parentName:"p"},"Hello, world!")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"Bye, world!"),".\nThis means adding another ",(0,l.yg)("inlineCode",{parentName:"p"},"write()")," system call."),(0,l.yg)("p",{parentName:"li"},(0,l.yg)("a",{parentName:"p",href:"Questions/syscall-id"},"Quiz 1")),(0,l.yg)("p",{parentName:"li"},(0,l.yg)("a",{parentName:"p",href:"Questions/syscall-tool"},"Quiz 2")),(0,l.yg)("p",{parentName:"li"},(0,l.yg)("a",{parentName:"p",href:"Questions/syscall-numbers"},"Quiz 3"))),(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Update the ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.asm")," and / or ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.s")," files to sleep before the ",(0,l.yg)("inlineCode",{parentName:"p"},"exit")," system call."),(0,l.yg)("p",{parentName:"li"},"You need to make the ",(0,l.yg)("inlineCode",{parentName:"p"},"sys_nanosleep()")," system call, with the ",(0,l.yg)("inlineCode",{parentName:"p"},"timespec")," structure.\nFind its ID ",(0,l.yg)("a",{parentName:"p",href:"https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/"},"here"),".")),(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Update the ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.asm")," and / or ",(0,l.yg)("inlineCode",{parentName:"p"},"hello.s")," files to read a message from standard input and print it to standard output."),(0,l.yg)("p",{parentName:"li"},"You'll need to define a buffer in the ",(0,l.yg)("inlineCode",{parentName:"p"},"data")," or ",(0,l.yg)("inlineCode",{parentName:"p"},"bss")," section.\nUse the ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," system call to read data in the buffer.\nThe return value of ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," (placed in the ",(0,l.yg)("inlineCode",{parentName:"p"},"rax")," register) is the number of bytes read.\nUse that value as the 3rd argument or ",(0,l.yg)("inlineCode",{parentName:"p"},"write"),", i.e. the number of bytes printed."),(0,l.yg)("p",{parentName:"li"},"Find the ID of the ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," system call ",(0,l.yg)("a",{parentName:"p",href:"https://x64.syscall.sh/"},"here"),".\nTo find out more about its arguments, see ",(0,l.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/read.2.html"},"its man page"),".\nStandard input descriptor is ",(0,l.yg)("inlineCode",{parentName:"p"},"0"),".")),(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},(0,l.yg)("strong",{parentName:"p"},"Difficult"),": Port the initial program to ARM on 64 bits (also called ",(0,l.yg)("strong",{parentName:"p"},"aarch64"),")."),(0,l.yg)("p",{parentName:"li"},"Use the skeleton files in the ",(0,l.yg)("inlineCode",{parentName:"p"},"arm/")," folder.\nFind information about the ",(0,l.yg)("inlineCode",{parentName:"p"},"aarch64")," system calls ",(0,l.yg)("a",{parentName:"p",href:"https://arm64.syscall.sh/"},"here"),".")),(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Create your own program, written in assembly, doing some system calls you want to learn more about.\nSome system calls you could try: ",(0,l.yg)("inlineCode",{parentName:"p"},"open()"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"rename()"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"mkdir()"),".\nCreate a Makefile for that program.\nRun the resulting program with ",(0,l.yg)("inlineCode",{parentName:"p"},"strace")," to see the actual system calls being made (and their arguments)."))),(0,l.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,l.yg)("a",{parentName:"p",href:"/operating-systems/136/Software%20Stack/lab1#analyzing-the-software-stack"},"this")," reading material."),(0,l.yg)("h2",{id:"task-system-call-wrappers"},"Task: System Call Wrappers"),(0,l.yg)("p",null,"Enter the ",(0,l.yg)("inlineCode",{parentName:"p"},"chapters/software-stack/system-calls/syscall-wrapper/drills/tasks/support/")," folder and go through the practice items below."),(0,l.yg)("ol",null,(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Update the files in the ",(0,l.yg)("inlineCode",{parentName:"p"},"support/")," folder to make ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," system call available as a wrapper.\nMake a call to the ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," system call to read data from standard input in a buffer.\nThen call ",(0,l.yg)("inlineCode",{parentName:"p"},"write()")," to print data from that buffer."),(0,l.yg)("p",{parentName:"li"},"Note that the ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," system call returns the number of bytes ",(0,l.yg)("inlineCode",{parentName:"p"},"read"),".\nUse that as the argument to the subsequent ",(0,l.yg)("inlineCode",{parentName:"p"},"write")," call that prints read data."),(0,l.yg)("p",{parentName:"li"},"We can see that it's easier to have wrapper calls and write most of the code in C than in assembly language."),(0,l.yg)("p",{parentName:"li"},(0,l.yg)("a",{parentName:"p",href:"Questions/syscall-wrapper"},"Quiz"))),(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Update the files in the ",(0,l.yg)("inlineCode",{parentName:"p"},"support/")," folder to make the ",(0,l.yg)("inlineCode",{parentName:"p"},"getpid")," system call available as a wrapper.\nCreate a function with the signature ",(0,l.yg)("inlineCode",{parentName:"p"},"unsigned int itoa(int n, char *a)")," that converts an integer to a string.\nIt returns the number of digits in the string.\nFor example, it will convert the number ",(0,l.yg)("inlineCode",{parentName:"p"},"1234")," to the string ",(0,l.yg)("inlineCode",{parentName:"p"},'"1234"')," string (",(0,l.yg)("inlineCode",{parentName:"p"},"NULL"),"-terminated, 5 bytes long);\nthe return value is ",(0,l.yg)("inlineCode",{parentName:"p"},"4")," (the number of digits of the ",(0,l.yg)("inlineCode",{parentName:"p"},'"1234"')," string)."),(0,l.yg)("p",{parentName:"li"},"Then make the call to ",(0,l.yg)("inlineCode",{parentName:"p"},"getpid"),";\nit gets no arguments and returns an integer (the PID - *process ID- of the current process)."))),(0,l.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,l.yg)("a",{parentName:"p",href:"/operating-systems/136/Software%20Stack/lab1#system-call-wrappers"},"this")," reading material."),(0,l.yg)("h2",{id:"task-library-calls-vs-system-calls"},"Task: Library Calls vs System Calls"),(0,l.yg)("p",null,"Enter the ",(0,l.yg)("inlineCode",{parentName:"p"},"chapters/software-stack/system-calls/drills/tasks/libcall-syscall/support/")," folder and go through the practice items below."),(0,l.yg)("ol",null,(0,l.yg)("li",{parentName:"ol"},(0,l.yg)("p",{parentName:"li"},"Check library calls and system calls for the ",(0,l.yg)("inlineCode",{parentName:"p"},"call2.c")," file.\nUse ",(0,l.yg)("inlineCode",{parentName:"p"},"ltrace")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"strace"),"."),(0,l.yg)("p",{parentName:"li"},"Find explanations for the calls being made and the library call to system call mapping."),(0,l.yg)("p",{parentName:"li"},(0,l.yg)("a",{parentName:"p",href:"Questions/libcall-syscall"},"Quiz")))),(0,l.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,l.yg)("a",{parentName:"p",href:"/operating-systems/136/Software%20Stack/lab1#library-calls-vs-system-calls"},"this")," reading material."),(0,l.yg)("h2",{id:"modern-software-stacks"},"Modern Software Stacks"),(0,l.yg)("p",null,"Most modern computing systems use a software stack such as the one in the figure below:"),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"Modern Software Stack",src:t(6119).A})),(0,l.yg)("p",null,"This modern software stack allows fast development and provides a rich set of applications to the user."),(0,l.yg)("p",null,"The basic software component is the ",(0,l.yg)("strong",{parentName:"p"},"operating system*- (OS) (technically the operating system "),"kernel",(0,l.yg)("strong",{parentName:"p"},").\nThe OS provides the fundamental primitives to interact with hardware (read and write data) and to manage the running of applications (such as memory allocation, thread creation, scheduling).\nThese primitives form the "),"system call API*- or ",(0,l.yg)("strong",{parentName:"p"},"system API"),".\nAn item in the system call API, i.e. the equivalent of a function call that triggers the execution of a functionality in the operating system, is a ",(0,l.yg)("strong",{parentName:"p"},"system call"),"."),(0,l.yg)("p",null,"The system call API is well-defined, stable and complete: it exposes the entire functionality of the operating system and hardware.\nHowever, it is also minimalistic with respect to features, and it provides a low-level (close to hardware) specification, making it cumbersome to use and ",(0,l.yg)("strong",{parentName:"p"},"not portable"),"."),(0,l.yg)("p",null,"Due to the downsides of the system call API, a basic library, the ",(0,l.yg)("strong",{parentName:"p"},"standard C library*- (also called "),"libc",(0,l.yg)("strong",{parentName:"p"},"), is built on top of it.\nBecause the system call API uses an OS-specific calling convention, the standard C library typically wraps each system call into an equivalent function call, following a portable calling convention.\nMore than these wrappers, the standard C library provides its own API that is typically portable.\nPart of the API exposed by the standard C library is the "),"standard C API",(0,l.yg)("strong",{parentName:"p"},", also called "),"ANSI C*- or ",(0,l.yg)("strong",{parentName:"p"},"ISO C"),";\nthis API is typically portable across all platforms (operating systems and hardware).\nThis API, going beyond system call wrappers, has several advantages:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"portability: irrespective of the underlying operating system (and system call API), the API is the same"),(0,l.yg)("li",{parentName:"ul"},"extensive features: string management, I/O formatting"),(0,l.yg)("li",{parentName:"ul"},"possibility of increased efficiency with techniques such as buffering, as we show later")),(0,l.yg)("h2",{id:"analyzing-the-software-stack"},"Analyzing the Software Stack"),(0,l.yg)("p",null,"To get a better grasp on how the software stack works, let's do a bottom-up approach:\nwe build and run different programs, that start off by using the system call API (the lowest layer in the software stack) and progressively use higher layers."),(0,l.yg)("h3",{id:"system-calls-explained"},"System Calls Explained"),(0,l.yg)("p",null,"A system call, or syscall for short, is a method used by applications to communicate with the operating system's kernel."),(0,l.yg)("p",null,"The need for syscalls is tied to the modern operating systems model of conceptually separating into kernel space and user space."),(0,l.yg)("p",null,"The kernel space manages the hardware resources such as CPU, I/O devices, disk or memory.\nMoreover, the kernel also provides an interface for the user space applications to interact with the hardware."),(0,l.yg)("p",null,"The user space is where you are running your applications and processes.\nFrom the user space, we cannot directly access the hardware or perform privileged operations.\nYou need to use syscalls to perform privileged operations such as accessing the hardware."),(0,l.yg)("p",null,"Below, you can see some examples of system calls and what resource they request from the kernel:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"brk()")," is used to allocate memory"),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"open()")," is used to access the file system and open a specific file"),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"write()")," is used to access the file system and modify the contents of a specific file")),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"System Call API Explained",src:t(5310).A})),(0,l.yg)("h3",{id:"basic-system-calls"},"Basic System Calls"),(0,l.yg)("p",null,"The ",(0,l.yg)("inlineCode",{parentName:"p"},"basic-syscall/support/")," folder stores the implementation of a simple program in assembly language for the x86_64 (64 bit) architecture.\nThe program invokes two system calls: ",(0,l.yg)("inlineCode",{parentName:"p"},"write")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"exit"),".\nThe program is duplicated in two files using the two x86 assembly language syntaxes: the Intel / NASM syntax (",(0,l.yg)("inlineCode",{parentName:"p"},"hello.asm"),") and the AT&T / GAS syntax (",(0,l.yg)("inlineCode",{parentName:"p"},"hello.s"),")."),(0,l.yg)("p",null,"The implementation follows the ",(0,l.yg)("a",{parentName:"p",href:"https://x64.syscall.sh/"},"x86_64 Linux calling convention"),":"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"system call ID is passed in the ",(0,l.yg)("inlineCode",{parentName:"li"},"rax")," register"),(0,l.yg)("li",{parentName:"ul"},"system call arguments are passed, in order, in the ",(0,l.yg)("inlineCode",{parentName:"li"},"rdi"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"rsi"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"rdx"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"r10"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"r8"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"r9")," registers")),(0,l.yg)("p",null,"Let's build and run the two programs:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../basic-syscall/support$ ls\nhello.asm  hello.s  Makefile\n\nstudent@os:~/.../basic-syscall/support$ make\nnasm -f elf64 -o hello-nasm.o hello.asm\ncc -nostdlib -no-pie -Wl,--entry=main -Wl,--build-id=none  hello-nasm.o   -o hello-nasm\ngcc -c -o hello-gas.o hello.s\ncc -nostdlib -no-pie -Wl,--entry=main -Wl,--build-id=none  hello-gas.o   -o hello-gas\n\nstudent@os:~/.../basic-syscall/support$ ls\nhello.asm  hello-gas  hello-gas.o  hello-nasm  hello-nasm.o  hello.s  Makefile\n\nstudent@os:~/.../basic-syscall/support$ ./hello-nasm\nHello, world!\nstudent@os:~/.../basic-syscall/support$ ./hello-gas\nHello, world!\n")),(0,l.yg)("p",null,"The two programs end up printing the ",(0,l.yg)("inlineCode",{parentName:"p"},"Hello, world!")," message at standard output by issuing the ",(0,l.yg)("inlineCode",{parentName:"p"},"write")," system call.\nThen they complete their work by issuing the ",(0,l.yg)("inlineCode",{parentName:"p"},"exit")," system call."),(0,l.yg)("p",null,"The ",(0,l.yg)("inlineCode",{parentName:"p"},"write")," system call writes a buffer to the file referred by the first argument, which is the file descriptor.\nFile descriptors are going to be studied in-depth in future chapters.\nFor now, it is enough for you to know that they are integers that behave like file handlers.\nThe 3 most common file descriptors are:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},(0,l.yg)("inlineCode",{parentName:"p"},"0")," references the standard input (",(0,l.yg)("inlineCode",{parentName:"p"},"stdin"),")")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},(0,l.yg)("inlineCode",{parentName:"p"},"1")," references the standard output (",(0,l.yg)("inlineCode",{parentName:"p"},"stdout"),")")),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("p",{parentName:"li"},(0,l.yg)("inlineCode",{parentName:"p"},"2")," references the standard error (",(0,l.yg)("inlineCode",{parentName:"p"},"stderr"),")"))),(0,l.yg)("p",null,"Use ",(0,l.yg)("inlineCode",{parentName:"p"},"man 2 write")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"man 3 exit")," to get a detailed understanding of the syntax and use of the two system calls.\nYou can also check the online man pages: ",(0,l.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/write.2.html"},(0,l.yg)("inlineCode",{parentName:"a"},"write")),", ",(0,l.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/exit.3.html"},(0,l.yg)("inlineCode",{parentName:"a"},"exit"))),(0,l.yg)("p",null,"We use ",(0,l.yg)("inlineCode",{parentName:"p"},"strace")," to inspect system calls issued by a program:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../basic-syscall/support$ strace ./hello-nasm\nexecve("./hello-nasm", ["./hello-nasm"], 0x7ffc4e175f00 /- 63 vars */) = 0\nwrite(1, "Hello, world!\\n", 14Hello, world!\n)         = 14\nexit(0)                                 = ?\n+++ exited with 0 +++\n')),(0,l.yg)("p",null,"There are three system calls captured by ",(0,l.yg)("inlineCode",{parentName:"p"},"strace"),":"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"execve()"),": this is issued by the shell to create the new process;\nyou'll find out more about ",(0,l.yg)("inlineCode",{parentName:"li"},"execve"),' in the "Compute" chapter'),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"write()"),": called by the program to print ",(0,l.yg)("inlineCode",{parentName:"li"},"Hello, world!")," to standard output"),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"exit()"),": to exit the program")),(0,l.yg)("p",null,"This is the most basic program for doing system calls.\nGiven that system calls require a specific calling convention, their invocation can only be done in assembly language.\nObviously, this is not portable (specific to a given CPU architecture, x86_64 in our case) and too verbose and difficult to maintain.\nFor portability and maintainability, we require a higher level language, such as C.\nIn order to use C, we need function wrappers around system calls."),(0,l.yg)("h2",{id:"system-call-wrappers"},"System Call Wrappers"),(0,l.yg)("p",null,"The ",(0,l.yg)("inlineCode",{parentName:"p"},"syscall-wrapper/support/")," folder stores the implementation of a simple program written in C (",(0,l.yg)("inlineCode",{parentName:"p"},"main.c"),") that calls the ",(0,l.yg)("inlineCode",{parentName:"p"},"write()")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"exit()")," functions.\nThe functions are defined in ",(0,l.yg)("inlineCode",{parentName:"p"},"syscall.asm")," as wrappers around corresponding system calls.\nEach function invokes the corresponding system call using the specific system call ID and the arguments provided for the function call."),(0,l.yg)("p",null,"The implementation of the two wrapper functions in ",(0,l.yg)("inlineCode",{parentName:"p"},"syscall.asm")," is very simple, as the function arguments are passed in the same registers required by the system call.\nThis is because of the overlap of the first three registers for the ",(0,l.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI"},"x86_64 Linux function calling convention")," and the ",(0,l.yg)("a",{parentName:"p",href:"https://x64.syscall.sh/"},"x86_64 Linux system call convention"),"."),(0,l.yg)("p",null,(0,l.yg)("inlineCode",{parentName:"p"},"syscall.h")," contains the declaration of the two functions and is included in ",(0,l.yg)("inlineCode",{parentName:"p"},"main.c"),".\nThis way, C programs can be written that make function calls that end up making system calls."),(0,l.yg)("p",null,"Let's build, run and trace system calls for the program:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../syscall-wrapper/support$ ls\nmain.c  Makefile  syscall.h  syscall.s\n\nstudent@os:~/.../syscall-wrapper/support$ make\ngcc -c -o main.o main.c\nnasm -f elf64 -o syscall.o syscall.s\ncc -nostdlib -no-pie -Wl,--entry=main -Wl,--build-id=none  main.o syscall.o   -o main\n\nstudent@os:~/.../syscall-wrapper/support$ ls\nmain  main.c  main.o  Makefile  syscall.h  syscall.o  syscall.s\n\nstudent@os:~/.../software-stack/lab/syscall-wrapper$ ./main\nHello, world!\n\nstudent@os:~/.../syscall-wrapper/support$ strace ./main\nexecve("./main", ["./main"], 0x7ffee60fb590 /- 63 vars */) = 0\nwrite(1, "Hello, world!\\n", 14Hello, world!\n)         = 14\nexit(0)                                 = ?\n+++ exited with 0 +++\n')),(0,l.yg)("p",null,"The trace is similar to the previous example, showing the ",(0,l.yg)("inlineCode",{parentName:"p"},"write()")," and ",(0,l.yg)("inlineCode",{parentName:"p"},"exit()")," system calls."),(0,l.yg)("p",null,"By creating system call wrappers as C functions, we are now relieved of the burden of writing assembly language code.\nOf course, there has to be an initial implementation of wrapper functions written in assembly language;\nbut, after that, we can use C only."),(0,l.yg)("h2",{id:"library-calls-vs-system-calls"},"Library calls vs System Calls"),(0,l.yg)("p",null,"The standard C library has primarily two uses:"),(0,l.yg)("ol",null,(0,l.yg)("li",{parentName:"ol"},"wrapping system calls into easier to use C-style library calls, such as ",(0,l.yg)("inlineCode",{parentName:"li"},"open()"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"write()"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"read()")),(0,l.yg)("li",{parentName:"ol"},"adding common functionality required for our program, such as string management (",(0,l.yg)("inlineCode",{parentName:"li"},"strcpy"),"), memory management (",(0,l.yg)("inlineCode",{parentName:"li"},"malloc()"),") or formatted I/O (",(0,l.yg)("inlineCode",{parentName:"li"},"printf()"),")")),(0,l.yg)("p",null,"The first use means a 1-to-1 mapping between library calls and system calls: one library call means one system call.\nThe second group doesn't have a standard mapping.\nA library call could be mapped to no system calls, one system call, two or more system calls, or it may depend (a system call may or may not happen)."),(0,l.yg)("p",null,"The ",(0,l.yg)("inlineCode",{parentName:"p"},"libcall-syscall/support")," folder stores the implementation of a simple program that makes different library calls.\nLet's build the program and then trace the library calls (with ",(0,l.yg)("inlineCode",{parentName:"p"},"ltrace"),") and the system calls (with ",(0,l.yg)("inlineCode",{parentName:"p"},"strace"),"):"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../libcall-syscall/support$ make\ncc -Wall   -c -o call.o call.c\ncc   call.o   -o call\ncc -Wall   -c -o call2.o call2.c\ncc   call2.o   -o call2\n\nstudent@os:~/.../libcall-syscall/support$ ltrace ./call\nfopen("a.txt", "wt")                                                                                             = 0x556d57679260\nstrlen("Hello, world!\\n")                                                                                        = 14\nfwrite("Hello, world!\\n", 1, 14, 0x556d57679260)                                                                 = 14\nstrlen("Bye, world!\\n")                                                                                          = 12\nfwrite("Bye, world!\\n", 1, 12, 0x556d57679260)                                                                   = 12\nfflush(0x556d57679260)                                                                                           = 0\n+++ exited (status 0) +++\n\nstudent@os:~/.../libcall-syscall/support$ strace ./call\n[...]\nopenat(AT_FDCWD, "a.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3\nfstat(3, {st_mode=S_IFREG|0664, st_size=0, ...}) = 0\nwrite(3, "Hello, world!\\nBye, world!\\n", 26) = 26\nexit_group(0)                           = ?\n+++ exited with 0 +++\n')),(0,l.yg)("p",null,"We have the following mappings:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"The ",(0,l.yg)("inlineCode",{parentName:"li"},"fopen()")," library call invokes the ",(0,l.yg)("inlineCode",{parentName:"li"},"openat")," and the ",(0,l.yg)("inlineCode",{parentName:"li"},"fstat")," system calls."),(0,l.yg)("li",{parentName:"ul"},"The ",(0,l.yg)("inlineCode",{parentName:"li"},"fwrite()")," library call invokes no system calls."),(0,l.yg)("li",{parentName:"ul"},"The ",(0,l.yg)("inlineCode",{parentName:"li"},"strlen()")," library call invokes no system calls."),(0,l.yg)("li",{parentName:"ul"},"The ",(0,l.yg)("inlineCode",{parentName:"li"},"fflush()")," library call invokes the ",(0,l.yg)("inlineCode",{parentName:"li"},"write")," system call.")),(0,l.yg)("p",null,"This all seems to make sense.\nThe main reason for ",(0,l.yg)("inlineCode",{parentName:"p"},"fwrite()")," not making any system calls is the use of a standard C library buffer.\nCalls the ",(0,l.yg)("inlineCode",{parentName:"p"},"fwrite()")," end up writing to that buffer to reduce the number of system calls.\nActual system calls are made either when the standard C library buffer is full or when an ",(0,l.yg)("inlineCode",{parentName:"p"},"fflush()")," library call is made."),(0,l.yg)("p",null,"Note that on some systems, ",(0,l.yg)("inlineCode",{parentName:"p"},"ltrace")," ",(0,l.yg)("strong",{parentName:"p"},"does not work*- as expected, due to "),"now binding",(0,l.yg)("strong",{parentName:"p"},".\nTo avoid this behaviour, you can force the "),"lazy binding",(0,l.yg)("em",{parentName:"p"},"- (based on which ",(0,l.yg)("inlineCode",{parentName:"em"},"ltrace")," is constructed to work).\nAn example can be found in ",(0,l.yg)("inlineCode",{parentName:"em"},"libcall-syscall/support/Makefile"),", however for system binaries, such as ",(0,l.yg)("inlineCode",{parentName:"em"},"ls")," or ",(0,l.yg)("inlineCode",{parentName:"em"},"pwd"),', the only alternative is to add the `-x "'),'"` argument to force the command to trace all symbols in the symbol table:'),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~$ ltrace -x "*" ls\n')),(0,l.yg)("p",null,"You can always choose what library functions ",(0,l.yg)("inlineCode",{parentName:"p"},"ltrace")," is investigating, by replacing the wildcard with their name:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~$ ltrace -x "malloc" -x "free" ls\nmalloc@libc.so.6(5)                                                    = 0x55c42b2b8910\nfree@libc.so.6(0x55c42b2b8910)                                         = <void>\nmalloc@libc.so.6(120)                                                  = 0x55c42b2b8480\nmalloc@libc.so.6(12)                                                   = 0x55c42b2b8910\nmalloc@libc.so.6(776)                                                  = 0x55c42b2b8930\nmalloc@libc.so.6(112)                                                  = 0x55c42b2b8c40\nmalloc@libc.so.6(1336)                                                 = 0x55c42b2b8cc0\nmalloc@libc.so.6(216)                                                  = 0x55c42b2b9200\nmalloc@libc.so.6(432)                                                  = 0x55c42b2b92e0\nmalloc@libc.so.6(104)                                                  = 0x55c42b2b94a0\nmalloc@libc.so.6(88)                                                   = 0x55c42b2b9510\nmalloc@libc.so.6(120)                                                  = 0x55c42b2b9570\n[...]\n')),(0,l.yg)("p",null,"If you would like to know more about ",(0,l.yg)("strong",{parentName:"p"},"lazy binding"),", ",(0,l.yg)("strong",{parentName:"p"},"now binding*- or "),"PLT*- entries, check out ",(0,l.yg)("a",{parentName:"p",href:"https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table"},"this blog post"),"."))}y.isMDXComponent=!0},6119:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/modern-sw-stack-4a2427d07a59c3a6599305b8eedc43dd.svg"},5310:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/syscall-explained-ff8f5182d632fa4fcf77ffd5f5fe958c.svg"}}]);