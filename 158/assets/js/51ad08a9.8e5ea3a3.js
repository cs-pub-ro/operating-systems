"use strict";(self.webpackChunkso=self.webpackChunkso||[]).push([[4436],{5680:(e,a,n)=>{n.d(a,{xA:()=>m,yg:()=>y});var t=n(6540);function o(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function l(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function r(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?l(Object(n),!0).forEach((function(a){o(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,o=function(e,a){if(null==e)return{};var n,t,o={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):r(r({},a),e)),n},m=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(n),d=o,y=c["".concat(s,".").concat(d)]||c[d]||g[d]||l;return n?t.createElement(y,r(r({ref:a},m),{},{components:n})):t.createElement(y,r({ref:a},m))}));function y(e,a){var n=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var l=n.length,r=new Array(l);r[0]=d;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i[c]="string"==typeof e?e:o,r[1]=i;for(var p=2;p<l;p++)r[p]=n[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2050:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>r,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var t=n(8168),o=(n(6540),n(5680));const l={},r="Lab 4 - Investigate Memory",i={unversionedId:"Data/lab4",id:"Data/lab4",title:"Lab 4 - Investigate Memory",description:"Task: Allocating and Deallocating Memory",source:"@site/docs/Data/lab4.md",sourceDirName:"Data",slug:"/Data/lab4",permalink:"/operating-systems/158/Data/lab4",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 3 - Memory",permalink:"/operating-systems/158/Data/lab3"},next:{title:"Lab 5 - Memory Security",permalink:"/operating-systems/158/Data/lab5"}},s={},p=[{value:"Task: Allocating and Deallocating Memory",id:"task-allocating-and-deallocating-memory",level:2},{value:"Task: Memory Mapping",id:"task-memory-mapping",level:2},{value:"Task: Memory Regions",id:"task-memory-regions",level:2},{value:"Task: Modifying Memory Region Size",id:"task-modifying-memory-region-size",level:2},{value:"Task: Memory Layout of Statically-Linked and Dynamically-Linked Executables",id:"task-memory-layout-of-statically-linked-and-dynamically-linked-executables",level:2},{value:"Task: Page Mapper",id:"task-page-mapper",level:2},{value:"Task: Operator overloading",id:"task-operator-overloading",level:2},{value:"Investigate Memory Actions",id:"investigate-memory-actions",level:2},{value:"<code>malloc()</code> in Musl",id:"malloc-in-musl",level:3},{value:"Guide: App Investigation: Deluge",id:"guide-app-investigation-deluge",level:2},{value:"Practice",id:"practice",level:3},{value:"Guide: App Investigation: Servo",id:"guide-app-investigation-servo",level:2},{value:"Practice",id:"practice-1",level:3},{value:"Guide: Investigation: Allocator in the D Programming Language",id:"guide-investigation-allocator-in-the-d-programming-language",level:2},{value:"Practice",id:"practice-2",level:3},{value:"Guide: App Investigation: Git",id:"guide-app-investigation-git",level:2},{value:"Practice",id:"practice-3",level:3},{value:"Guide: <code>jemalloc</code>",id:"guide-jemalloc",level:2},{value:"Guide: Memory Actions (and Leaks) in Existing Programs",id:"guide-memory-actions-and-leaks-in-existing-programs",level:2},{value:"Practice",id:"practice-4",level:3},{value:"Guide: Memory Leaks",id:"guide-memory-leaks",level:2},{value:"Practice",id:"practice-5",level:3}],m={toc:p},c="wrapper";function g(e){let{components:a,...n}=e;return(0,o.yg)(c,(0,t.A)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"lab-4---investigate-memory"},"Lab 4 - Investigate Memory"),(0,o.yg)("h2",{id:"task-allocating-and-deallocating-memory"},"Task: Allocating and Deallocating Memory"),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/alloc-size/support")," directory."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Use ",(0,o.yg)("inlineCode",{parentName:"p"},"pmap")," to analyze the process address space for ",(0,o.yg)("inlineCode",{parentName:"p"},"ALLOC_SIZE_KB")," initialized to ",(0,o.yg)("inlineCode",{parentName:"p"},"256"),".\nNotice the new memory areas and the difference between the use of ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap")," syscall and ",(0,o.yg)("inlineCode",{parentName:"p"},"brk")," syscall.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Use ",(0,o.yg)("inlineCode",{parentName:"p"},"valgrind")," on the resulting executable, and notice there are memory leaks.\nThey are quite obvious due to the lack of proper freeing.\nSolve the leaks.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Use ",(0,o.yg)("inlineCode",{parentName:"p"},"valgrind")," on different executables in the system (in ",(0,o.yg)("inlineCode",{parentName:"p"},"/bin/"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"/usr/bin/"),") and see if they have memory leaks."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-memory-mapping"},"Task: Memory Mapping"),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/copy/")," directory, run ",(0,o.yg)("inlineCode",{parentName:"p"},"make skels")," and open the ",(0,o.yg)("inlineCode",{parentName:"p"},"support/src")," directory.\nHere you will find these files:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"read_write_copy.c")," in which you will implement copying with ",(0,o.yg)("inlineCode",{parentName:"li"},"read")," / ",(0,o.yg)("inlineCode",{parentName:"li"},"write")," syscalls"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"mmap_copy.c")," in which you will implement copying using ",(0,o.yg)("inlineCode",{parentName:"li"},"mmap")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"benchmark_cp.sh")," script which runs the two executables ",(0,o.yg)("inlineCode",{parentName:"li"},"mmap_copy")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"read_write_copy"))),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Complete the implementations for the ",(0,o.yg)("inlineCode",{parentName:"p"},"read_write_copy.c")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap_copy.c")," files.\nThe goal is to copy the ",(0,o.yg)("inlineCode",{parentName:"p"},"in.dat")," file to ",(0,o.yg)("inlineCode",{parentName:"p"},"out.dat")," using the ",(0,o.yg)("inlineCode",{parentName:"p"},"read")," / ",(0,o.yg)("inlineCode",{parentName:"p"},"write")," syscalls and ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap")," respectively.\nCheck your work by running the ",(0,o.yg)("inlineCode",{parentName:"p"},"checker.sh")," script in the ",(0,o.yg)("inlineCode",{parentName:"p"},"support/tests/")," directory.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Once you have a working implementation, run the ",(0,o.yg)("inlineCode",{parentName:"p"},"benchmark_cp.sh")," script to compare the performance of the two approaches.\nThe output should look like this:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../drills/tasks/copy/support$ ./benchmark_cp.sh\nBenchmarking mmap_copy on in.dat\ntime passed 54015 microseconds\n\nBenchmarking read_write_copy on in.dat\ntime passed 42011 microseconds\n")),(0,o.yg)("p",{parentName:"li"},"Run the script a few more times.\nAs you can see, there isn't much of a difference between the two approaches.\nAlthough we would have expected the use of multiple system calls to cause overhead, it's too little compared to the memory copying overhead.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Add a ",(0,o.yg)("inlineCode",{parentName:"p"},"sleep()")," call to the ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap_copy.c")," file ",(0,o.yg)("strong",{parentName:"p"},"after")," the files were mapped.\nRebuild the program and run it.\nOn a different console, use ",(0,o.yg)("inlineCode",{parentName:"p"},"pmap")," to view the two new memory regions that were added to the process, by mapping the ",(0,o.yg)("inlineCode",{parentName:"p"},"in.dat")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"out.dat")," files."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-memory-regions"},"Task: Memory Regions"),(0,o.yg)("p",null,"Enter the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/memory-areas/support")," directory.\nWe investigate other programs."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"The ",(0,o.yg)("inlineCode",{parentName:"p"},"hello.c")," program prints out a message and then sleeps.\nBuild it:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../drills/tasks/memory-areas/support$ make\n")),(0,o.yg)("p",{parentName:"li"},"then run it (it will block):"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../drills/tasks/memory-areas/support$ ./hello\nHello, world!\n")),(0,o.yg)("p",{parentName:"li"},"In another terminal, use the command below to show the memory areas of the process:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../drills/tasks/memory-areas/support$ pmap $(pidof hello)\n8220:   ./hello\n000055c0bef4b000      8K r-x-- hello\n000055c0bf14c000      4K r---- hello\n000055c0bf14d000      4K rw--- hello\n000055c0bf454000    132K rw---   [ anon ]\n00007f2a9e4a5000   1948K r-x-- libc-2.27.so\n00007f2a9e68c000   2048K ----- libc-2.27.so\n00007f2a9e88c000     16K r---- libc-2.27.so\n00007f2a9e890000      8K rw--- libc-2.27.so\n00007f2a9e892000     16K rw---   [ anon ]\n00007f2a9e896000    164K r-x-- ld-2.27.so\n00007f2a9ea8c000      8K rw---   [ anon ]\n00007f2a9eabf000      4K r---- ld-2.27.so\n00007f2a9eac0000      4K rw--- ld-2.27.so\n00007f2a9eac1000      4K rw---   [ anon ]\n00007ffee6471000    132K rw---   [ stack ]\n00007ffee6596000     12K r----   [ anon ]\n00007ffee6599000      4K r-x--   [ anon ]\nffffffffff600000      4K --x--   [ anon ]\n total             4520K\n")),(0,o.yg)("p",{parentName:"li"},"The output is similar, but with fewer dynamic libraries than ",(0,o.yg)("inlineCode",{parentName:"p"},"bash"),", since they are not used by the program.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Make a program in another language of your choice that prints ",(0,o.yg)("inlineCode",{parentName:"p"},"Hello, world!")," and sleeps and investigate it with ",(0,o.yg)("inlineCode",{parentName:"p"},"pmap"),".\nNote that in the case of interpreted languages (Python, Lua, Perl, Ruby, PHP, JavaScript etc.) you have to investigate the interpreter process."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-modifying-memory-region-size"},"Task: Modifying Memory Region Size"),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/modify-areas/support")," directory."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Comment out different parts of the ",(0,o.yg)("inlineCode",{parentName:"p"},"hello.c")," program to notice differences in only specific areas (text, data, bss, heap, stack).")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Use a different argument (",(0,o.yg)("inlineCode",{parentName:"p"},"order"),") for the call to the ",(0,o.yg)("inlineCode",{parentName:"p"},"alloc_stack()")," function.\nSee how it affects the stack size during runtime (investigate with ",(0,o.yg)("inlineCode",{parentName:"p"},"pmap"),").")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Do a static build of ",(0,o.yg)("inlineCode",{parentName:"p"},"hello.c")," and check the size of the memory areas, both statically and dynamically.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"The ",(0,o.yg)("inlineCode",{parentName:"p"},"extend_mem_area.py")," Python script allocates a new string at each step by merging the two previous versions.\nStart the program and investigate the resulting process at each allocation step.\nNotice which memory area is updated and explain why."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-memory-layout-of-statically-linked-and-dynamically-linked-executables"},"Task: Memory Layout of Statically-Linked and Dynamically-Linked Executables"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Let's investigate another static executable / process."),(0,o.yg)("p",{parentName:"li"},"If not already installed, install the ",(0,o.yg)("inlineCode",{parentName:"p"},"busybox-static")," package on your system.\nOn Debian/Ubuntu systems, use:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~$ sudo apt install busybox-static\n")),(0,o.yg)("p",{parentName:"li"},"Start a process using:"),(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~$ busybox sleep 1000\n")),(0,o.yg)("p",{parentName:"li"},"Investigate the process using ",(0,o.yg)("inlineCode",{parentName:"p"},"pmap")," and the executable using ",(0,o.yg)("inlineCode",{parentName:"p"},"size"),"."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-page-mapper"},"Task: Page Mapper"),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/page-mapper/support")," directory."),(0,o.yg)("p",null,"Your goal is to update the ",(0,o.yg)("inlineCode",{parentName:"p"},"src/page_mapper.c")," source code file to reserve virtual pages in the address space of the current process.\nUse ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap()")," to reserve virtual pages.\nUse anonymous mapping (i.e. the ",(0,o.yg)("inlineCode",{parentName:"p"},"MAP_ANONYMOUS"),") flag.\nUse any permissions required."),(0,o.yg)("p",null,"Inside the ",(0,o.yg)("inlineCode",{parentName:"p"},"src/")," directory, use ",(0,o.yg)("inlineCode",{parentName:"p"},"make")," to do a quick check of the implementation.\nTo test it, enter the ",(0,o.yg)("inlineCode",{parentName:"p"},"tests/")," directory and run:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"make check\n")),(0,o.yg)("p",null,"In case of a correct solution, you will get an output such as:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-text"},"./run_all_tests.sh\ntest_res_1                       ........................ passed ...  25\ntest_res_2                       ........................ passed ...  25\ntest_res_10                      ........................ passed ...  25\ntest_res_10_res_20               ........................ passed ...  25\n\nTotal:                                                           100/100\n")),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"task-operator-overloading"},"Task: Operator overloading"),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/process-memory/drills/tasks/reference-counting/support")," directory.\nAnalyze the ",(0,o.yg)("inlineCode",{parentName:"p"},"operators.d")," file.\nA ",(0,o.yg)("inlineCode",{parentName:"p"},"struct")," is defined that also implements 4 special functions: a constructor, a copy constructor, an assignment operator and a destructor.\nEach of these special functions may be called automatically by the compiler:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"the constructor is called automatically whenever an object is initialized with a field of a type that corresponds to the constructor parameter type."),(0,o.yg)("li",{parentName:"ul"},"the copy constructor is called automatically when an object is initialized from an object of the same type."),(0,o.yg)("li",{parentName:"ul"},"the assignment operator is called automatically when an object is assigned an object of the same type."),(0,o.yg)("li",{parentName:"ul"},"the destructor is called automatically whenever an object goes out of scope.")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Note: the difference between initialization and assignment is that the initialization occurs when an object is being declared and occurs a single time (",(0,o.yg)("inlineCode",{parentName:"strong"},"Obj o1 = 1"),"), whereas assignment is decoupled from the declaration site and may occur multiple times (provided that the variable is mutable).")),(0,o.yg)("p",null,"Compile and run the program in ",(0,o.yg)("inlineCode",{parentName:"p"},"operators.d"),".\nNotice how the different special functions are automatically called.\nConsidering the definition of ",(0,o.yg)("inlineCode",{parentName:"p"},"Obj")," from the file ",(0,o.yg)("inlineCode",{parentName:"p"},"operators.d"),", answer the following."),(0,o.yg)("p",null,"Analyze the ",(0,o.yg)("inlineCode",{parentName:"p"},"refcount_skel.d"),".\nA reference counted ",(0,o.yg)("inlineCode",{parentName:"p"},"int")," array is implemented, however, some bits are missing.\nRun the code, try to understand what happens."),(0,o.yg)("p",null,"The constructor allocates memory for the array, whereas the destructor deallocates it.\nCompile and run the code.\nNotice how the array's memory  is automatically managed."),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Uncomment the following line in the ",(0,o.yg)("inlineCode",{parentName:"p"},"main")," function (",(0,o.yg)("inlineCode",{parentName:"p"},"//test1()"),").\nRun the code.\nWhat happens?\nWhy?")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"The reference counted array does not implement the copy constructor.\nComment the ",(0,o.yg)("inlineCode",{parentName:"p"},"version(none)")," annotation for the copy constructor and implement the logic so that the reference counted array is correct.\nWhen an object is initialized from another object, we need to appropriately set the fields and then increment the reference count.\nOnce you have completed this exercise, make sure the output is correct and that the reference counted array is not freed too early.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Uncomment the following line in the ",(0,o.yg)("inlineCode",{parentName:"p"},"main")," function (",(0,o.yg)("inlineCode",{parentName:"p"},"//test2()"),").\nRun the code.\nWhat happens?\nWhy?\nUse GDB to find out.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"The reference counted array does not implement the assignment operator.\nComment the ",(0,o.yg)("inlineCode",{parentName:"p"},"version(none)")," annotation for the assignment operator and implement the logic so that the reference counted array is correct.\nWhen an object is assigned to another object, we need to first decrement the count for the object that is being assigned to, then fill the fields similarly to the copy constructor case and lastly increment the count for the assigned object.\nAfter completing the exercise, make sure that the memory is properly managed.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Play with your reference counted array and create different scenarios to test its limits."))),(0,o.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,o.yg)("a",{parentName:"p",href:"/operating-systems/158/Data/lab3#process-memory"},"this")," reading material."),(0,o.yg)("h2",{id:"investigate-memory-actions"},"Investigate Memory Actions"),(0,o.yg)("p",null,"Memory actions generally mean:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"memory access: read, write or execute"),(0,o.yg)("li",{parentName:"ul"},"memory allocation"),(0,o.yg)("li",{parentName:"ul"},"memory deallocation")),(0,o.yg)("p",null,"By far, the most important actions are allocation and deallocation.\nBecause, if not done right, these can get to memory loss and poor memory use."),(0,o.yg)("p",null,"Memory loss generally happens in the form of memory leaks."),(0,o.yg)("h3",{id:"malloc-in-musl"},(0,o.yg)("inlineCode",{parentName:"h3"},"malloc()")," in Musl"),(0,o.yg)("p",null,"Each libc (or memory allocator such as ",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc"),") uses their own implementation of ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," and other functions.\n",(0,o.yg)("a",{parentName:"p",href:"https://musl.libc.org/"},"Musl libc")," is a lightweight standard C library that provides compatible features with the more heavyweights ",(0,o.yg)("a",{parentName:"p",href:"https://www.gnu.org/software/libc/"},"GNU libc"),"."),(0,o.yg)("p",null,"Take a look through implementation of ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," in ",(0,o.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/malloc"},"Musl libc"),".\nSee all three implementations for ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),":"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"the one in ",(0,o.yg)("inlineCode",{parentName:"li"},"lite_malloc.c")),(0,o.yg)("li",{parentName:"ul"},"the one in ",(0,o.yg)("inlineCode",{parentName:"li"},"mallocng/malloc.c")),(0,o.yg)("li",{parentName:"ul"},"the one in ",(0,o.yg)("inlineCode",{parentName:"li"},"oldmalloc/malloc"))),(0,o.yg)("p",null,"See also ",(0,o.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/malloc/mallocng/free.c#L101"},"the implementation of ",(0,o.yg)("inlineCode",{parentName:"a"},"free()")),".\nAnd ",(0,o.yg)("a",{parentName:"p",href:"https://elixir.bootlin.com/musl/v1.2.3/source/src/malloc/calloc.c#L33"},"the implementation of ",(0,o.yg)("inlineCode",{parentName:"a"},"calloc()")),"."),(0,o.yg)("p",null,"You needn't spend too much time browsing the implementation of these functions, just having a broad understanding of how they work."),(0,o.yg)("h2",{id:"guide-app-investigation-deluge"},"Guide: App Investigation: Deluge"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://www.deluge-torrent.org/"},"Deluge")," is a Bittorrent client written in Python."),(0,o.yg)("p",null,"We want to locate places that allocate memory in Deluge (in Python).\nThis generally means locating instantiation of classes."),(0,o.yg)("p",null,"Let's clone the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/deluge-torrent/deluge"},"source code"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../app-investigation$ git clone https://github.com/deluge-torrent/deluge\nCloning into 'deluge'...\n[...]\n\nstudent@os:~/.../app-investigation$ cd deluge/\n\nstudent@os:~/.../app-investigation/deluge$ ls\nAUTHORS       deluge      docs             gen_web_gettext.py  MANIFEST.in       msgfmt.py  pyproject.toml  requirements-dev.txt    requirements.txt  setup.py  version.py\nCHANGELOG.md  DEPENDS.md  generate_pot.py  LICENSE             minify_web_js.py  packaging  README.md       requirements-tests.txt  setup.cfg         tox.ini\n")),(0,o.yg)("p",null,"And enter the ",(0,o.yg)("inlineCode",{parentName:"p"},"deluge/core/")," subdirectory:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../app-investigation/deluge$ cd deluge/core/\n\nstudent@os:~/.../deluge/deluge/core$ ls\nalertmanager.py  core.py          daemon.py        filtermanager.py  pluginmanager.py       rpcserver.py       torrent.py\nauthmanager.py   daemon_entry.py  eventmanager.py  __init__.py       preferencesmanager.py  torrentmanager.py\n")),(0,o.yg)("p",null,"Most files in the subdirectory have a class defined.\nWe can search for instantiations of that class using ",(0,o.yg)("inlineCode",{parentName:"p"},"grep"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../deluge/deluge/core$ grep -rn 'Torrent('\ntorrentmanager.py:644:        torrent = Torrent(handle, options, state, filename, magne\n\nstudent@os:~/.../deluge/deluge/core$ grep -rn 'TorrentManager('\ncore.py:139:        self.torrentmanager = TorrentManager()\ntorrentmanager.py:135:class TorrentManager(component.Component):\n")),(0,o.yg)("p",null,"This gives us an overview of when memory is allocated in Deluge / Python."),(0,o.yg)("h3",{id:"practice"},"Practice"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Investigate the lines shown to contain instantiations of classes.\nExplore the source code and understand their placements in the source code.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Find out other classes and search for their instantiation in the source code."))),(0,o.yg)("h2",{id:"guide-app-investigation-servo"},"Guide: App Investigation: Servo"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://servo.org/"},"Servo")," is a browser engine written in Rust that provides reusable components to implement web standards."),(0,o.yg)("p",null,"We do not clone the repository, since it's very large."),(0,o.yg)("p",null,"We find information about allocator used, by accessing the ",(0,o.yg)("inlineCode",{parentName:"p"},"components/allocator/")," in ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/servo/servo/tree/master/components/allocator"},"its source code"),".\nIn ",(0,o.yg)("inlineCode",{parentName:"p"},"Cargo.toml")," we see that it requires ",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," for non-Windows implementations and the standard Windows API (called ",(0,o.yg)("inlineCode",{parentName:"p"},"heapapi"),") for Windows:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-text"},'[...]\n[lib]\npath = "lib.rs"\n\n[target.\'cfg(not(windows))\'.dependencies]\njemalloc-sys = { version = "0.3.2" }\n\n[target.\'cfg(windows)\'.dependencies]\nwinapi = { version = "0.3", features = ["heapapi"] }\nust: https://github.com/servo/servo\n')),(0,o.yg)("p",null,"In ",(0,o.yg)("inlineCode",{parentName:"p"},"lib.rs"),", in ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/servo/servo/blob/master/components/allocator/lib.rs#L70"},(0,o.yg)("inlineCode",{parentName:"a"},"GlobalAlloc:alloc()"))," we see it is using ",(0,o.yg)("a",{parentName:"p",href:"https://jemalloc.net/jemalloc.3.html"},"the ",(0,o.yg)("inlineCode",{parentName:"a"},"mallocx")," custom function from ",(0,o.yg)("inlineCode",{parentName:"a"},"jemalloc()")),".\nSee ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/servo/servo/blob/master/components/allocator/lib.rs#L17"},"the initialization of ",(0,o.yg)("inlineCode",{parentName:"a"},"ffi")),"."),(0,o.yg)("p",null,"See the use of the allocator in the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/servo/servo/blob/master/components/net/Cargo.toml"},(0,o.yg)("inlineCode",{parentName:"a"},"Cargo.toml")," file in the ",(0,o.yg)("inlineCode",{parentName:"a"},"net")," component"),".\nSearch for the ",(0,o.yg)("inlineCode",{parentName:"p"},"alloc")," string."),(0,o.yg)("h3",{id:"practice-1"},"Practice"),(0,o.yg)("p",null,"Look for uses of the allocator in other components of Servo."),(0,o.yg)("h2",{id:"guide-investigation-allocator-in-the-d-programming-language"},"Guide: Investigation: Allocator in the D Programming Language"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://github.com/dlang/phobos"},"Phobos")," is the standard library that comes with the D programming language compiler."),(0,o.yg)("p",null,"Let's clone the source code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../d-allocator$ git clone https://github.com/dlang/phobos\n[...]\n\nstudent@os:~/.../d-allocator$ cd phobos/\n\nstudent@os:~/.../d-allocator/phobos$ ls\nazure-pipelines.yml  changelog  CODEOWNERS  CONTRIBUTING.md  dub.sdl  etc  index.dd  LICENSE_1_0.txt  posix.mak  project.ddoc  README.md  std  test  unittest.d  win32.mak  win64.mak\n")),(0,o.yg)("p",null,"And enter ",(0,o.yg)("inlineCode",{parentName:"p"},"std/experimental/allocator/")," to browse information about the allocator:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../d-allocator/phobos$ cd std/experimental/allocator/\n\nstudent@os:~/.../std/experimental/allocator$ ls\nbuilding_blocks  common.d  gc_allocator.d  mallocator.d  mmap_allocator.d  package.d  showcase.d  typed.d\n")),(0,o.yg)("p",null,"We then do a search of the ",(0,o.yg)("inlineCode",{parentName:"p"},"allocate(")," string to find instances of allocation calls:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../std/experimental/allocator$ grep -r 'allocate('\n[...]\n")),(0,o.yg)("p",null,"We see that there are definitions of the function (as expected) as part of ",(0,o.yg)("inlineCode",{parentName:"p"},"...allocator")," files: ",(0,o.yg)("inlineCode",{parentName:"p"},"mallocator.d"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"gc_allocator.d"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap_allocator.d"),".\nBrowse the functions and look for implementations of the ",(0,o.yg)("inlineCode",{parentName:"p"},"allocate()")," function."),(0,o.yg)("h3",{id:"practice-2"},"Practice"),(0,o.yg)("p",null,"Do a similar search and then source code browsing for the ",(0,o.yg)("inlineCode",{parentName:"p"},"deallocate()")," function."),(0,o.yg)("h2",{id:"guide-app-investigation-git"},"Guide: App Investigation: Git"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://git-scm.com/"},"Git")," is among the most used source code management system, powering development infrastructures such as ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/"},"GitHub"),", ",(0,o.yg)("a",{parentName:"p",href:"https://about.gitlab.com/"},"GitLab")," and ",(0,o.yg)("a",{parentName:"p",href:"https://bitbucket.org/"},"Bitbucket"),"."),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/investigate-memory/guides/git")," directory."),(0,o.yg)("p",null,"Let's clone ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/git/git"},"the repository"),".\nNote that it is about 200MB large:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../git$ git clone https://github.com/git/git\n[...]\n\nstudent@os:~/.../git$ cd git/\n")),(0,o.yg)("p",null,"We look of uses of ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../git/git$ grep -r 'malloc(' .\n")),(0,o.yg)("p",null,"We see there are multiple calls to the ",(0,o.yg)("inlineCode",{parentName:"p"},"xmalloc()")," function, which is likely a wrapper for ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),".\nWe search for the definition of ",(0,o.yg)("inlineCode",{parentName:"p"},"xmalloc()"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../git/git$ grep -rn 'xmalloc(' . | grep -v ';'\n./commit.c:188:                 graft = xmalloc(st_add(sizeof(*graft),\n./add-interactive.c:157:        list->sorted.items = xmalloc(st_mult(sizeof(*list->sorted.items),\n./Documentation/RelNotes/2.24.0.txt:91: * xmalloc() used to have a mechanism to ditch memory and address\n./Documentation/RelNotes/2.24.0.txt:210:   xmalloc() wrapper, as the rest of the system, for consistency.\n./Documentation/RelNotes/2.34.0.txt:230: * mmap() imitation used to call xmalloc() that dies upon malloc()\n./Documentation/RelNotes/2.33.1.txt:44: * mmap() imitation used to call xmalloc() that dies upon malloc()\n./diffcore-delta.c:56:  new_spanhash = xmalloc(st_add(sizeof(*orig),\n./diffcore-delta.c:135: hash = xmalloc(st_add(sizeof(*hash),\n./kwset.c:41:/* adapter for `xmalloc()`, which takes `size_t`, not `long` */\n./builtin/fast-import.c:461:    b = xmalloc(sizeof(struct object_entry_pool)\n./hashmap.h:311: * your structure was allocated with xmalloc(), you can just free(3) it,\n./xdiff/xdiff.h:122:#define xdl_malloc(x) xmalloc(x)\n./wrapper.c:45:static void *do_xmalloc(size_t size, int gentle)\n./wrapper.c:70:void *xmalloc(size_t size)\n./contrib/credential/wincred/git-credential-wincred.c:26:static void *xmalloc(size_t size)\nBinary file ./.git/objects/pack/pack-c587b9f11a82bc4d49848d74132e60ea4dbeb177.pack matches\n./git-compat-util.h:1046:# define xalloca(size)      (xmalloc(size))\n./git-compat-util.h:1086:#define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))\n./read-cache.c:3768:    ieot = xmalloc(sizeof(struct index_entry_offset_table)\n")),(0,o.yg)("p",null,"Line ",(0,o.yg)("inlineCode",{parentName:"p"},"./wrapper.c:70")," is the one with the definition of the ",(0,o.yg)("inlineCode",{parentName:"p"},"xmalloc()")," function.\nIt makes a call of the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/git/git/blob/master/wrapper.c#L45"},(0,o.yg)("inlineCode",{parentName:"a"},"do_xmalloc()")," function"),", that makes extra checks.\nAlso, if the ",(0,o.yg)("inlineCode",{parentName:"p"},"XMALLOC_POISON"),' macro is defined, all the allocated data is overwritten with a "poison" value (',(0,o.yg)("inlineCode",{parentName:"p"},"0xA5"),").\nThis is useful for early detection of memory-related issues, although, evidently, it adds overhead."),(0,o.yg)("p",null,"We can look for parts of the source code with the largest number of uses of ",(0,o.yg)("inlineCode",{parentName:"p"},"xmalloc()"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../git/git$ grep -rc 'xmalloc(' . | grep -v ':0' | sort -n -t ':' -k 20\n[...]\n./compat/mingw.c:6\n./submodule-config.c:6\n./merge-recursive.c:7\n")),(0,o.yg)("p",null,"We can look into the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/git/git/blob/master/merge-recursive.c"},(0,o.yg)("inlineCode",{parentName:"a"},"merge-recursive.c")," file")," for uses of the ",(0,o.yg)("inlineCode",{parentName:"p"},"xmalloc()")," function."),(0,o.yg)("h3",{id:"practice-3"},"Practice"),(0,o.yg)("p",null,"Do the same actions as above for the ",(0,o.yg)("inlineCode",{parentName:"p"},"mmap()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"xmmap()")," function calls."),(0,o.yg)("p",null,"Note that these are not memory allocation calls, since a valid ",(0,o.yg)("inlineCode",{parentName:"p"},"fd")," file argument is passed.\nThese are file mapping calls, that we will talk more as part of the I/O chapter."),(0,o.yg)("h2",{id:"guide-jemalloc"},"Guide: ",(0,o.yg)("inlineCode",{parentName:"h2"},"jemalloc")),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"http://jemalloc.net/"},(0,o.yg)("inlineCode",{parentName:"a"},"jemalloc"))," is a featureful allocator that is intended to replace the standard allocator in the standard C library (libc).\n",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," provides replacements for the general ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," functions, and also provides a custom API targeted for performance tuning."),(0,o.yg)("p",null,"As ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/jemalloc/jemalloc/wiki/Getting-Started"},"documented"),", there are multiple ways to use ",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc"),", the easiest of which is to use the ",(0,o.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," environment variable and preload the library and hook into ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," function calls."),(0,o.yg)("p",null,"Navigate to the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/investigate-memory/guides/jemalloc")," directory."),(0,o.yg)("p",null,"First install ",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," on our system.\nOn your typical Ubuntu / Debian-based system, use ",(0,o.yg)("inlineCode",{parentName:"p"},"apt"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../jemalloc$ sudo apt -y install libjemalloc-dev\n")),(0,o.yg)("p",null,"Note that this installs the distribution package, not the latest one (that may provide more features)."),(0,o.yg)("p",null,"With this in place, we can use ",(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," against our pre-built executables or system executables (such as ",(0,o.yg)("inlineCode",{parentName:"p"},"ls"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"ps"),").\nWe can test it against the executable files from ",(0,o.yg)("inlineCode",{parentName:"p"},"support/memory-leak/"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../jemalloc$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so ./memory_leak_malloc\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n")),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," can use the ",(0,o.yg)("inlineCode",{parentName:"p"},"MALLOC_CONF")," environment variable for a ",(0,o.yg)("a",{parentName:"p",href:"https://www.freebsd.org/cgi/man.cgi?query=malloc.conf"},"diverse set of configurations"),".\nFor example, by using ",(0,o.yg)("inlineCode",{parentName:"p"},"stats_print:true")," we print out information regarding the use of the library functions:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../jemalloc$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so MALLOC_CONF="stats_print:true" ./memory_leak_malloc\nAndrei Popescu is 22 years old and likes Linux\nIoana David is 23 years old and likes macOS\n___ Begin jemalloc statistics ___\nVersion: 3.6.0-11\nAssertions disabled\nRun-time option settings:\n  opt.abort: false\n  opt.lg_chunk: 22\n  opt.dss: "secondary"\n  opt.narenas: 32\n  opt.lg_dirty_mult: 3\n  opt.stats_print: true\n  opt.junk: false\n  opt.quarantine: 0\n  opt.redzone: false\n[...]\ndirty pages: 26:0 active:dirty, 0 sweeps, 0 madvises, 0 purged\n            allocated      nmalloc      ndalloc    nrequests\nsmall:          72672          114            0            3\nlarge:          32768            1            0            1\ntotal:         105440          115            0            4\nactive:        106496\nmapped:       4194304\n[...]\n')),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"jemalloc")," doesn't work against system executables using preloading, likely because of security options disabling the use of the library:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~/.../jemalloc$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so MALLOC_CONF="stats_print:true" /bin/ls\nMakefile  memory_leak  memory_leak.cpp  memory_leak_malloc  memory_leak_malloc.c  memory_leak_malloc.o  memory_leak.o\n\nstudent@os:~/.../jemalloc$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so MALLOC_CONF="stats_print:true" /bin/ps\n  PID TTY          TIME CMD\n 1581 pts/22   00:00:00 ps\n26732 pts/22   00:00:01 bash\n')),(0,o.yg)("h2",{id:"guide-memory-actions-and-leaks-in-existing-programs"},"Guide: Memory Actions (and Leaks) in Existing Programs"),(0,o.yg)("p",null,"We can use Valgrind to investigate existing programs in the system.\nThis tells us whether they possess memory leaks:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-actions$ valgrind ls\n==24669== Memcheck, a memory error detector\n==24669== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==24669== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==24669== Command: ls\n==24669==\nMakefile  memory_leak  memory_leak.cpp  memory_leak_malloc  memory_leak_malloc.c  memory_leak_malloc.o  memory_leak.o\n==24669==\n==24669== HEAP SUMMARY:\n==24669==     in use at exit: 21,696 bytes in 14 blocks\n==24669==   total heap usage: 51 allocs, 37 frees, 61,331 bytes allocated\n==24669==\n==24669== LEAK SUMMARY:\n==24669==    definitely lost: 0 bytes in 0 blocks\n==24669==    indirectly lost: 0 bytes in 0 blocks\n==24669==      possibly lost: 0 bytes in 0 blocks\n==24669==    still reachable: 21,696 bytes in 14 blocks\n==24669==         suppressed: 0 bytes in 0 blocks\n==24669== Rerun with --leak-check=full to see details of leaked memory\n==24669==\n==24669== For counts of detected and suppressed errors, rerun with: -v\n==24669== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\nstudent@os:~/.../memory-actions$ valgrind ps\n==24671== Memcheck, a memory error detector\n==24671== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==24671== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==24671== Command: ps\n==24671==\n  PID TTY          TIME CMD\n24671 pts/22   00:00:00 memcheck-amd64-\n26732 pts/22   00:00:01 bash\n==24671==\n==24671== HEAP SUMMARY:\n==24671==     in use at exit: 264,929 bytes in 25 blocks\n==24671==   total heap usage: 692 allocs, 667 frees, 334,268 bytes allocated\n==24671==\n==24671== LEAK SUMMARY:\n==24671==    definitely lost: 0 bytes in 0 blocks\n==24671==    indirectly lost: 0 bytes in 0 blocks\n==24671==      possibly lost: 0 bytes in 0 blocks\n==24671==    still reachable: 264,929 bytes in 25 blocks\n==24671==         suppressed: 0 bytes in 0 blocks\n==24671== Rerun with --leak-check=full to see details of leaked memory\n==24671==\n==24671== For counts of detected and suppressed errors, rerun with: -v\n==24671== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\nstudent@os:~/.../memory-actions$ valgrind bash -c 'echo \"ha\"'\n==24675== Memcheck, a memory error detector\n==24675== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==24675== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==24675== Command: bash -c echo\\ \"ha\"\n==24675==\nha\n==24675==\n==24675== HEAP SUMMARY:\n==24675==     in use at exit: 43,056 bytes in 672 blocks\n==24675==   total heap usage: 774 allocs, 102 frees, 51,405 bytes allocated\n==24675==\n==24675== LEAK SUMMARY:\n==24675==    definitely lost: 12 bytes in 1 blocks\n==24675==    indirectly lost: 0 bytes in 0 blocks\n==24675==      possibly lost: 0 bytes in 0 blocks\n==24675==    still reachable: 43,044 bytes in 671 blocks\n==24675==         suppressed: 0 bytes in 0 blocks\n==24675== Rerun with --leak-check=full to see details of leaked memory\n==24675==\n==24675== For counts of detected and suppressed errors, rerun with: -v\n==24675== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n")),(0,o.yg)("p",null,"We can see that ",(0,o.yg)("inlineCode",{parentName:"p"},"ls")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"ps")," don't have memory leaks.\nHowever, the shell (Bash) shows a memory leak of 12 bytes (on the test system).\nThis may be a false positive or the subject of an actual investigation."),(0,o.yg)("p",null,"Note that the ",(0,o.yg)("inlineCode",{parentName:"p"},"still reachable")," section of the output refers to memory that wasn't freed, but still has pointers referring to it.\nA true memory leak occurs when no pointers refer any memory area."),(0,o.yg)("h3",{id:"practice-4"},"Practice"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Investigate 2-3 other executables in the system using Valgrind.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Use ",(0,o.yg)("inlineCode",{parentName:"p"},"ltrace")," to list ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," calls made by the investigated system executables."))),(0,o.yg)("p",null,"Note that, as explained in the ",(0,o.yg)("a",{parentName:"p",href:"https://open-education-hub.github.io/operating-systems/Lab/Software%20Stack/libcall-syscall"},"Software Stack lab"),", on some systems, ",(0,o.yg)("inlineCode",{parentName:"p"},"ltrace")," does not accurately show the output, due to ",(0,o.yg)("em",{parentName:"p"},"now binding"),".\nFear not, you can always check the library calls with a more verbose and harder to parse ",(0,o.yg)("inlineCode",{parentName:"p"},"ltrace")," command:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'student@os:~$ ltrace -x "*"\n')),(0,o.yg)("h2",{id:"guide-memory-leaks"},"Guide: Memory Leaks"),(0,o.yg)("p",null,"A memory leak happens when a memory region is allocated but no longer accessible.\nThis typically occurs when a pointer that referenced a memory area is redirected to a new memory location, leaving the original memory area unreachable and unable to be freed."),(0,o.yg)("p",null,"Enter the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/investigate-memory/guides/memory-leak")," folder, run ",(0,o.yg)("inlineCode",{parentName:"p"},"make skels"),".\nEnter the ",(0,o.yg)("inlineCode",{parentName:"p"},"chapters/data/investigate-memory/guides/memory-leak/support/src")," directory.\nIt stores two files showing memory leaks:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"one in C++: ",(0,o.yg)("inlineCode",{parentName:"li"},"memory_leak.cpp")),(0,o.yg)("li",{parentName:"ul"},"one in C: ",(0,o.yg)("inlineCode",{parentName:"li"},"memory_leak_malloc.c"))),(0,o.yg)("p",null,"Let's build and run the two executables:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-leak/support/src$ make\ng++    -c -o memory_leak.o memory_leak.cpp\ncc   memory_leak.o  -lstdc++ -o memory_leak\ncc    -c -o memory_leak_malloc.o memory_leak_malloc.c\ncc   memory_leak_malloc.o  -lstdc++ -o memory_leak_malloc\n")),(0,o.yg)("p",null,"Running them yields similar output:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-leak/support/src$ ./memory_leak\nLinus Torvalds is 22 years old and likes Linux\nSteve Jobs is 23 years old and likes macOS\nstudent@os:~/.../memory-leak/support/src$ ./memory_leak_malloc\nLinus Torvalds is 22 years old and likes Linux\nSteve Jobs is 23 years old and likes macOS\n")),(0,o.yg)("p",null,"We investigate the memory leaks of the two programs by using ",(0,o.yg)("a",{parentName:"p",href:"https://valgrind.org/"},"Valgrind"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-leak/support/src$ valgrind ./memory_leak\n==22362== Memcheck, a memory error detector\n==22362== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==22362== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==22362== Command: ./memory_leak\n==22362==\nLinus Torvalds is 22 years old and likes Linux\nSteve Jobs is 23 years old and likes macOS\n==22362==\n==22362== HEAP SUMMARY:\n==22362==     in use at exit: 72 bytes in 1 blocks\n==22362==   total heap usage: 4 allocs, 3 frees, 73,872 bytes allocated\n==22362==\n==22362== LEAK SUMMARY:\n==22362==    definitely lost: 72 bytes in 1 blocks\n==22362==    indirectly lost: 0 bytes in 0 blocks\n==22362==      possibly lost: 0 bytes in 0 blocks\n==22362==    still reachable: 0 bytes in 0 blocks\n==22362==         suppressed: 0 bytes in 0 blocks\n==22362== Rerun with --leak-check=full to see details of leaked memory\n==22362==\n==22362== For counts of detected and suppressed errors, rerun with: -v\n==22362== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n\nstudent@os:~/.../memory-leak/support/src$ valgrind ./memory_leak_malloc\n==22369== Memcheck, a memory error detector\n==22369== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==22369== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==22369== Command: ./memory_leak_malloc\n==22369==\nLinus Torvalds is 22 years old and likes Linux\nSteve Jobs is 23 years old and likes macOS\n==22369==\n==22369== HEAP SUMMARY:\n==22369==     in use at exit: 148 bytes in 1 blocks\n==22369==   total heap usage: 3 allocs, 2 frees, 1,320 bytes allocated\n==22369==\n==22369== LEAK SUMMARY:\n==22369==    definitely lost: 148 bytes in 1 blocks\n==22369==    indirectly lost: 0 bytes in 0 blocks\n==22369==      possibly lost: 0 bytes in 0 blocks\n==22369==    still reachable: 0 bytes in 0 blocks\n==22369==         suppressed: 0 bytes in 0 blocks\n==22369== Rerun with --leak-check=full to see details of leaked memory\n==22369==\n==22369== For counts of detected and suppressed errors, rerun with: -v\n==22369== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n")),(0,o.yg)("p",null,"As we are doing allocations that are not freed, this results in memory leaks."),(0,o.yg)("p",null,"For ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),"-based programs, we can use ",(0,o.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/mtrace.3.html"},(0,o.yg)("inlineCode",{parentName:"a"},"mtrace()")," feature")," and ",(0,o.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/mtrace.1.html"},(0,o.yg)("inlineCode",{parentName:"a"},"mtrace")," command")," to verify proper allocations with ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and deallocations with ",(0,o.yg)("inlineCode",{parentName:"p"},"free()"),".\nWe call ",(0,o.yg)("inlineCode",{parentName:"p"},"mtrace()")," in the program (in ",(0,o.yg)("inlineCode",{parentName:"p"},"memory_leak_malloc.c"),") to enable ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"free()")," checking."),(0,o.yg)("p",null,"To use ",(0,o.yg)("inlineCode",{parentName:"p"},"mtrace()")," we define the ",(0,o.yg)("inlineCode",{parentName:"p"},"MALLOC_TRACE")," environment variable.\nWe probably also require to preload the libc ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc")," debugging library, so we use ",(0,o.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," for that.\nNote that the file path used for ",(0,o.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," may need to be updated, depending on your distribution:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-leak/support/src$ LD_PRELOAD=/lib/x86_64-linux-gnu/libc_malloc_debug.so.0 MALLOC_TRACE=mem.trace ./memory_leak_malloc\nLinus Torvalds is 22 years old and likes Linux\nSteve Jobs is 23 years old and likes macOS\n")),(0,o.yg)("p",null,"Subsequently, we use the ",(0,o.yg)("inlineCode",{parentName:"p"},"mtrace")," tool to show information about the leaked data:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@os:~/.../memory-leak/support/src$ mtrace ./memory_leak_malloc mem.trace\n\nMemory not freed:\n-----------------\n           Address     Size     Caller\n0x000056506d8be6a0     0x94  at 0x56506c3777ec\n")),(0,o.yg)("p",null,"The size (",(0,o.yg)("inlineCode",{parentName:"p"},"0x94"),") is the same value shown by Valgrind (",(0,o.yg)("inlineCode",{parentName:"p"},"148"),")."),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"mtrace")," provides an outcome similar to Valgrind.\nValgrind is however more powerful: it works on different types of memory (not only those allocated with ",(0,o.yg)("inlineCode",{parentName:"p"},"malloc()"),") and it doesn't require access to the source code (and the compiler phase)."),(0,o.yg)("h3",{id:"practice-5"},"Practice"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Print the size of the ",(0,o.yg)("inlineCode",{parentName:"p"},"Student")," class and the ",(0,o.yg)("inlineCode",{parentName:"p"},"struct student")," structure to see if it equates to the leak shown by Valgrind.")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},"Solve the memory leaks in both programs.\nRun the checker (",(0,o.yg)("inlineCode",{parentName:"p"},"./checker.sh")," in the ",(0,o.yg)("inlineCode",{parentName:"p"},"memory-leak/support/tests/")," folder) to check your results."),(0,o.yg)("p",{parentName:"li"},"Sample run:"))),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},"student@so:~/.../support/tests/$ ./checker.sh\nmake: Entering directory '/home/student/operating-systems/chapters/data/investigate-memory/guides/memory-leak/support/src'\ng++    -c -o memory_leak.o memory_leak.cpp\ncc   memory_leak.o  -lstdc++ -o memory_leak\ncc    -c -o memory_leak_malloc.o memory_leak_malloc.c\ncc   memory_leak_malloc.o  -lstdc++ -o memory_leak_malloc\nmake: Leaving directory '/home/student/operating-systems/chapters/data/investigate-memory/guides/memory-leak/support/src'\n-------------------------------------------------\nChecking memory leaks for C executable: ../src/memory_leak\nC executable is leak-free!\n\nPoints for ../src/memory_leak: 50/50\n-------------------------------------------------\nChecking memory leaks for C++ executable: ../src/memory_leak_malloc\nC++ executable is leak-free!\n\nPoints for ../src/memory_leak_malloc: 50/50\n-------------------------------------------------\nTotal Points: 100/100\n")))}g.isMDXComponent=!0}}]);